/* automatically generated by rust-bindgen 0.72.1 */

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub type prover_t = ::std::os::raw::c_void;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bytes_t {
    pub len: u32,
    pub data: *mut u8,
}

/// Buffer structure for growing byte arrays (matches C's buffer_t)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffer_t {
    pub data: bytes_t,
    pub allocated: i32,
}

/// Storage plugin callback type for get operation
/// Returns true if key found and data copied to buffer, false otherwise
pub type storage_get_fn =
    Option<unsafe extern "C" fn(key: *mut ::std::os::raw::c_char, buffer: *mut buffer_t) -> bool>;

/// Storage plugin callback type for set operation
pub type storage_set_fn =
    Option<unsafe extern "C" fn(key: *mut ::std::os::raw::c_char, value: bytes_t)>;

/// Storage plugin callback type for delete operation
pub type storage_del_fn = Option<unsafe extern "C" fn(key: *mut ::std::os::raw::c_char)>;

/// Storage plugin configuration (matches C's storage_plugin_t from plugin.h)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storage_plugin_t {
    pub get: storage_get_fn,
    pub set: storage_set_fn,
    pub del: storage_del_fn,
    pub max_sync_states: u32,
}

unsafe extern "C" {
    #[doc = " Creates a new prover context for generating a proof.\n\n This function initializes the proof generation process for a specific Ethereum RPC method.\n The returned context must be used with `c4_prover_execute_json_status()` to drive the\n asynchronous proof generation process.\n\n **Memory Management**: The caller is responsible for freeing the returned context using\n `c4_free_prover_ctx()` when done.\n\n @param method The Ethereum RPC method to prove (e.g., \"eth_getBalance\", \"eth_getBlockByHash\")\n @param params The method parameters as a JSON array string (e.g., '[\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\", \"latest\"]')\n @param chain_id The blockchain chain ID (1 = Ethereum Mainnet, 11155111 = Sepolia, etc.)\n @param flags Flags to customize proof generation:\n              - Bit 0 (0x01): Include contract code in proof\n              - Other bits reserved for future use\n @return A new prover context pointer, or NULL if creation failed\n\n **Example**:\n ```c\n prover_t* ctx = c4_create_prover_ctx(\n     \"eth_getBalance\",\n     \"[\\\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\\\", \\\"latest\\\"]\",\n     1,\n     0\n );\n if (!ctx) {\n     fprintf(stderr, \"Failed to create prover context\\n\");\n     return -1;\n }\n ```"]
    pub fn c4_create_prover_ctx(
        method: *mut ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_char,
        chain_id: u64,
        flags: u32,
    ) -> *mut prover_t;
}
unsafe extern "C" {
    #[doc = " Executes one step of the proof generation state machine.\n\n This function drives the asynchronous proof generation process. Call it repeatedly in a loop\n until it returns a status of \"success\" or \"error\". When it returns \"pending\", the host system\n must handle the pending data requests before calling this function again.\n\n **Memory Management**: The returned JSON string must be freed by the caller using `free()`.\n\n @param ctx The prover context created by `c4_create_prover_ctx()`\n @return A JSON string describing the current status (see format below)\n\n **Return Value Format**:\n\n The function returns a JSON string with one of three possible statuses:\n\n **Success** (proof generation complete):\n ```json\n {\n   \"status\": \"success\",\n   \"result\": \"0x7ffe1234abcd\",\n   \"result_len\": 1024\n }\n ```\n - `result`: Hexadecimal string pointer to proof data (use with `c4_prover_get_proof()`)\n - `result_len`: Length of the proof in bytes\n\n **Error** (proof generation failed):\n ```json\n {\n   \"status\": \"error\",\n   \"error\": \"Failed to fetch block header: connection timeout\"\n }\n ```\n - `error`: Human-readable error message\n\n **Pending** (waiting for external data):\n ```json\n {\n   \"status\": \"pending\",\n   \"requests\": [\n     {\n       \"req_ptr\": 140736471234560,\n       \"chain_id\": 1,\n       \"type\": \"beacon_api\",\n       \"encoding\": \"json\",\n       \"method\": \"get\",\n       \"url\": \"eth/v1/beacon/light_client/finality_update\",\n       \"exclude_mask\": 0\n     },\n     {\n       \"req_ptr\": 140736471234688,\n       \"chain_id\": 1,\n       \"type\": \"eth_rpc\",\n       \"encoding\": \"json\",\n       \"method\": \"post\",\n       \"url\": \"\",\n       \"payload\": {\n         \"method\": \"eth_getBlockByNumber\",\n         \"params\": [\"0x1234\", false]\n       },\n       \"exclude_mask\": 0\n     }\n   ]\n }\n ```\n - `requests`: Array of data requests that must be fulfilled (see \"Data Request Structure\" in API docs)\n\n **Example Usage**:\n ```c\n prover_t* ctx = c4_create_prover_ctx(\"eth_getBalance\", \"[\\\"0xabc...\\\", \\\"latest\\\"]\", 1, 0);\n\n while (1) {\n     char* status_json = c4_prover_execute_json_status(ctx);\n\n     // Parse JSON (use your favorite JSON parser)\n     json_t status = parse_json(status_json);\n     free(status_json);\n\n     if (strcmp(status.status, \"success\") == 0) {\n         bytes_t proof = c4_prover_get_proof(ctx);\n         // Use the proof...\n         break;\n     } else if (strcmp(status.status, \"error\") == 0) {\n         fprintf(stderr, \"Error: %s\\n\", status.error);\n         break;\n     } else if (strcmp(status.status, \"pending\") == 0) {\n         // Handle pending requests (see Host System Responsibilities)\n         for (int i = 0; i < status.requests_count; i++) {\n             handle_request(&status.requests[i]);\n         }\n     }\n }\n\n c4_free_prover_ctx(ctx);\n ```"]
    pub fn c4_prover_execute_json_status(ctx: *mut prover_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieves the generated proof from a completed prover context.\n\n This function should only be called after `c4_prover_execute_json_status()` returns\n a status of \"success\". The proof data is owned by the context and remains valid until\n `c4_free_prover_ctx()` is called.\n\n **Memory Management**: The returned bytes_t.data pointer is owned by the context.\n Do NOT call `free()` on it. Copy the data if you need to retain it after freeing the context.\n\n @param ctx The prover context (must be in \"success\" state)\n @return A bytes_t structure containing the proof data\n\n **Example**:\n ```c\n // After successful proof generation\n bytes_t proof = c4_prover_get_proof(ctx);\n\n // Copy proof data for later use\n uint8_t* proof_copy = malloc(proof.len);\n memcpy(proof_copy, proof.data, proof.len);\n\n // Now safe to free context\n c4_free_prover_ctx(ctx);\n\n // Use proof_copy...\n free(proof_copy);\n ```"]
    pub fn c4_prover_get_proof(ctx: *mut prover_t) -> bytes_t;
}
unsafe extern "C" {
    #[doc = " Frees all resources associated with a prover context.\n\n This function must be called to clean up a prover context created by `c4_create_prover_ctx()`.\n After calling this function, the context pointer is invalid and must not be used.\n\n **Memory Management**: This frees the context and all associated internal memory, including\n the proof data. If you need the proof data after freeing the context, copy it first using\n `c4_prover_get_proof()`.\n\n @param ctx The prover context to free (may be NULL, in which case this is a no-op)\n\n **Example**:\n ```c\n prover_t* ctx = c4_create_prover_ctx(...);\n // ... use context ...\n c4_free_prover_ctx(ctx);\n ctx = NULL; // Good practice to avoid use-after-free\n ```"]
    pub fn c4_free_prover_ctx(ctx: *mut prover_t);
}
unsafe extern "C" {
    #[doc = " Sets the successful response data for a pending data request.\n\n When `c4_prover_execute_json_status()` or `c4_verify_execute_json_status()` returns\n `\"status\": \"pending\"`, the host system must fetch the data for each request and call\n this function to provide the response. After all pending requests are fulfilled, call\n the execute function again to continue processing.\n\n **Memory Management**: The data is **copied** by this function. The caller retains ownership\n of the input data and is responsible for freeing it if needed.\n\n @param req_ptr Opaque request pointer from the \"req_ptr\" field in the JSON status\n @param data The response data as bytes_t (will be copied)\n @param node_index Index of the node that provided this response (0-15, used for exclude_mask)\n\n **Example**:\n ```c\n // Parse pending requests from JSON status\n for (each request in status.requests) {\n     void* req_ptr = request.req_ptr;\n\n     // Fetch data from network\n     uint8_t* response_data = fetch_url(request.url);\n     size_t response_len = get_response_length();\n\n     // Set response (data is copied, so safe to free after)\n     bytes_t response = { .len = response_len, .data = response_data };\n     c4_req_set_response(req_ptr, response, node_index);\n\n     free(response_data); // Safe to free immediately\n }\n ```"]
    pub fn c4_req_set_response(
        req_ptr: *mut ::std::os::raw::c_void,
        data: bytes_t,
        node_index: u16,
    );
}
unsafe extern "C" {
    #[doc = " Sets an error for a pending data request.\n\n When a data request cannot be fulfilled (network error, all nodes failed, invalid response),\n call this function to report the error. The proof generation/verification will typically\n fail with this error message, or may retry with different parameters.\n\n **Memory Management**: The error string is **copied** by this function. The caller retains\n ownership and is responsible for freeing it if needed.\n\n @param req_ptr Opaque request pointer from the \"req_ptr\" field in the JSON status\n @param error Error message string (will be copied)\n @param node_index Index of the node that failed (0-15), or 0 if all nodes failed\n\n **Example**:\n ```c\n // Try to fetch from multiple nodes\n char* last_error = NULL;\n for (int i = 0; i < num_nodes; i++) {\n     if (request.exclude_mask & (1 << i)) continue; // Skip excluded nodes\n\n     if (try_fetch(nodes[i], request.url, &response)) {\n         c4_req_set_response(req_ptr, response, i);\n         return; // Success\n     } else {\n         last_error = get_last_error();\n     }\n }\n\n // All nodes failed\n c4_req_set_error(req_ptr, last_error ? last_error : \"All nodes failed\", 0);\n ```"]
    pub fn c4_req_set_error(
        req_ptr: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_char,
        node_index: u16,
    );
}
unsafe extern "C" {
    #[doc = " Creates a verification context for verifying a proof.\n\n This function initializes the proof verification process. The returned context must be\n used with `c4_verify_execute_json_status()` to drive the asynchronous verification process.\n\n Verification may require additional data from external sources (e.g., beacon chain finality\n updates, sync committee data), so it follows the same asynchronous execution model as\n proof generation.\n\n **Memory Management**: The caller is responsible for freeing the returned context using\n `c4_verify_free_ctx()` when done.\n\n @param proof The proof data to verify\n @param method The Ethereum RPC method that was proven (e.g., \"eth_getBalance\")\n @param args The method arguments as JSON array string (must match proof)\n @param chain_id The blockchain chain ID (must match proof)\n @param trusted_checkpoint Optional trusted checkpoint as hex string (0x-prefixed, 66 chars),\n                           or NULL/empty string to use the default checkpoint for this chain\n @return A new verification context pointer, or NULL if creation failed\n\n **Trusted Checkpoints**:\n\n A trusted checkpoint is a 32-byte hash of a beacon chain block root that is assumed to be\n correct. Colibri uses this checkpoint as the starting point for verification, avoiding the\n need to sync from genesis.\n\n - **Format**: `\"0x\" + 64 hex characters` (66 characters total)\n - **Recommended**: Use a recent finalized beacon block root from a trusted source\n - **If NULL**: Uses the built-in checkpoint for the chain (may be outdated)\n\n **Example**:\n ```c\n // Verify a proof with a trusted checkpoint\n bytes_t proof = { .len = proof_len, .data = proof_data };\n void* ctx = c4_verify_create_ctx(\n     proof,\n     \"eth_getBalance\",\n     \"[\\\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\\\", \\\"latest\\\"]\",\n     1, // Ethereum Mainnet\n     \"0x1234567890abcdef...\" // Trusted checkpoint (66 chars)\n );\n\n if (!ctx) {\n     fprintf(stderr, \"Failed to create verification context\\n\");\n     return -1;\n }\n ```"]
    pub fn c4_verify_create_ctx(
        proof: bytes_t,
        method: *mut ::std::os::raw::c_char,
        args: *mut ::std::os::raw::c_char,
        chain_id: u64,
        trusted_checkpoint: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Executes one step of the proof verification state machine.\n\n This function drives the asynchronous proof verification process. Call it repeatedly in a loop\n until it returns a status of \"success\" or \"error\". When it returns \"pending\", the host system\n must handle the pending data requests before calling this function again.\n\n The execution flow is identical to `c4_prover_execute_json_status()`, but returns the verified\n result instead of a proof.\n\n **Memory Management**: The returned JSON string must be freed by the caller using `free()`.\n\n @param ctx The verification context created by `c4_verify_create_ctx()`\n @return A JSON string describing the current status (see format below)\n\n **Return Value Format**:\n\n **Success** (verification complete):\n ```json\n {\n   \"status\": \"success\",\n   \"result\": {\n     // The verified RPC result (format depends on method)\n     // For eth_getBalance: \"0x1234567890abcdef\"\n     // For eth_getBlockByNumber: { number: \"0x1234\", hash: \"0xabcd...\", ... }\n   }\n }\n ```\n\n **Error** (verification failed):\n ```json\n {\n   \"status\": \"error\",\n   \"error\": \"Invalid proof: Merkle root mismatch\"\n }\n ```\n\n **Pending** (waiting for external data):\n ```json\n {\n   \"status\": \"pending\",\n   \"requests\": [\n     // Same format as c4_prover_execute_json_status()\n   ]\n }\n ```\n\n **Example Usage**:\n ```c\n void* ctx = c4_verify_create_ctx(proof, method, args, chain_id, checkpoint);\n\n while (1) {\n     char* status_json = c4_verify_execute_json_status(ctx);\n\n     json_t status = parse_json(status_json);\n     free(status_json);\n\n     if (strcmp(status.status, \"success\") == 0) {\n         printf(\"Verified result: %s\\n\", json_stringify(status.result));\n         break;\n     } else if (strcmp(status.status, \"error\") == 0) {\n         fprintf(stderr, \"Verification failed: %s\\n\", status.error);\n         break;\n     } else if (strcmp(status.status, \"pending\") == 0) {\n         for (int i = 0; i < status.requests_count; i++) {\n             handle_request(&status.requests[i]);\n         }\n     }\n }\n\n c4_verify_free_ctx(ctx);\n ```"]
    pub fn c4_verify_execute_json_status(
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Frees all resources associated with a verification context.\n\n This function must be called to clean up a verification context created by\n `c4_verify_create_ctx()`. After calling this function, the context pointer is\n invalid and must not be used.\n\n @param ctx The verification context to free (may be NULL, in which case this is a no-op)\n\n **Example**:\n ```c\n void* ctx = c4_verify_create_ctx(...);\n // ... use context ...\n c4_verify_free_ctx(ctx);\n ctx = NULL; // Good practice\n ```"]
    pub fn c4_verify_free_ctx(ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Queries whether a specific RPC method is supported and how it should be handled.\n\n Not all Ethereum RPC methods can be cryptographically proven. This function returns\n information about method support, allowing the host system to decide how to handle\n each RPC call.\n\n @param chain_id The blockchain chain ID to check\n @param method The Ethereum RPC method name (e.g., \"eth_getBalance\")\n @return Method support type (see table below)\n\n **Return Values**:\n\n | Value | Name | Meaning | How to Handle |\n |-------|------|---------|---------------|\n | 1 | PROOFABLE | Method can be cryptographically proven | Use proof generation and verification flow |\n | 2 | UNPROOFABLE | Method exists but cannot be proven | Call RPC node directly without proof |\n | 3 | NOT_SUPPORTED | Method is not supported by Colibri | Return error to caller |\n | 4 | LOCAL | Method can be computed locally | Use verification with empty proof |\n | 0 | UNKNOWN | Unknown method or error | Treat as NOT_SUPPORTED |\n\n **Proofable Methods** (return 1):\n - State queries: `eth_getBalance`, `eth_getCode`, `eth_getStorageAt`, `eth_getProof`\n - Transaction queries: `eth_getTransactionByHash`, `eth_getTransactionReceipt`, `eth_getTransactionByBlockHashAndIndex`, `eth_getTransactionByBlockNumberAndIndex`\n - Block queries: `eth_getBlockByHash`, `eth_getBlockByNumber`, `eth_getBlockTransactionCountByHash`, `eth_getBlockTransactionCountByNumber`\n - Log queries: `eth_getLogs`\n - Call simulation: `eth_call`, `eth_estimateGas`\n\n **Unproofable Methods** (return 2):\n - Mempool: `eth_sendTransaction`, `eth_sendRawTransaction`, `eth_getTransactionCount` (pending)\n - Mining: `eth_mining`, `eth_hashrate`, `eth_getWork`, `eth_submitWork`\n - Network: `net_listening`, `net_peerCount`\n\n **Local Methods** (return 4):\n - `eth_chainId`: Returns the configured chain ID\n - `net_version`: Returns the network version (same as chain ID)\n\n **Example**:\n ```c\n int support = c4_get_method_support(1, \"eth_getBalance\");\n\n switch (support) {\n     case 1: // PROOFABLE\n         printf(\"Creating proof for eth_getBalance...\\n\");\n         // Use c4_create_prover_ctx() + c4_verify_create_ctx()\n         break;\n     case 2: // UNPROOFABLE\n         printf(\"Calling eth_getBalance directly on RPC...\\n\");\n         // Make HTTP request to RPC node\n         break;\n     case 3: // NOT_SUPPORTED\n         printf(\"Method eth_getBalance not supported\\n\");\n         return error;\n     case 4: // LOCAL\n         printf(\"Computing eth_chainId locally...\\n\");\n         // Use c4_verify_create_ctx() with empty proof\n         break;\n }\n ```"]
    pub fn c4_get_method_support(
        chain_id: u64,
        method: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Configure the storage plugin for the C library.
    /// This registers callbacks that the C library will use to store/retrieve data.
    pub fn c4_set_storage_config(plugin: *mut storage_plugin_t);

    /// Get the current storage plugin configuration.
    #[allow(dead_code)]
    pub fn c4_get_storage_config(plugin: *mut storage_plugin_t);

    /// Grow a buffer to hold at least min_len bytes.
    /// Returns the available length of the buffer.
    pub fn buffer_grow(buffer: *mut buffer_t, min_len: usize) -> usize;
}

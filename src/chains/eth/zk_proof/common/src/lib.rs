use serde::{Deserialize, Serialize};

pub mod merkle;

/// The input provided to the SP1 Guest Program.
/// This structure contains all necessary data to prove a single chain transition
/// or a recursive chain of transitions.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SP1GuestInput {
    /// The proof data for the current period transition.
    /// Contains the sync committee signatures, the next sync committee keys, and the Merkle proofs
    /// connecting them to the `current_keys_root`.
    pub proof_data: ProofData,

    /// Optional recursion data.
    /// If present, this input indicates a recursive proof step. The guest will verify
    /// the validity of the previous proof (represented by this data) before proceeding
    /// with the current period transition.
    pub recursion_data: Option<RecursionData>,
}

/// Data required to verify a previous SP1 proof recursively within the guest.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RecursionData {
    /// The hash of the verification key (VK) for the SP1 program.
    /// This ensures that the previous proof was generated by the *same* program logic
    /// (or a specifically authorized one).
    pub vkey_hash: [u32; 8],

    /// The SHA-256 digest of the public values from the previous proof.
    /// This digest is used to verify the integrity of `public_values`.
    pub public_values_digest: [u8; 32],

    /// The actual public values output by the previous proof.
    /// For this program, it is a serialized `VerificationOutput` struct containing
    /// the `current_keys_root` (trust anchor), `next_keys_root` (result of the chain so far),
    /// and `next_period` (the period reached by the previous proof).
    pub public_values: Vec<u8>,
}

/// Core data structures for the Light Client Update proof.
/// This mirrors the Ethereum LightClientUpdate structure but includes
/// auxiliary data needed for ZK verification (like the full list of keys).
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ProofData {
    /// The SSZ HashTreeRoot of the current sync committee's public keys.
    /// Acts as the "Trust Anchor" for this specific transition.
    /// The guest verifies that the signatures provided in `signature` and `signature_bits`
    /// correspond to keys committed to by this root.
    pub current_keys_root: [u8; 32],

    /// The SSZ HashTreeRoot of the *next* sync committee's public keys.
    /// This is the "Output" of the transition. If the signatures are valid,
    /// the verifier can trust that this root represents the legitimate next committee.
    pub next_keys_root: [u8; 32],

    /// The period number of the *next* sync committee.
    /// e.g., if this proof validates the transition from period 1599, this will be 1600.
    pub next_period: u64,

    /// The full list of 512 BLS public keys (serialized) for the *current* sync committee.
    /// The guest reconstructs the `current_keys_root` from these keys to ensure they match the input root.
    /// These keys are then used to aggregate and verify the BLS signature.
    /// Format: 512 * 48 bytes.
    pub current_keys: Vec<u8>,

    /// A bitfield indicating which validators from the `current_keys` participated in the signature.
    /// Length is typically 64 bytes (512 bits).
    pub signature_bits: Vec<u8>,

    /// The aggregated BLS signature of the participating validators.
    /// Verifies that >2/3 of the committee signed the header containing the `next_keys_root`.
    pub signature: Vec<u8>,

    /// The slot number of the attested header (serialized as little-endian bytes).
    /// Used to construct the "Signing Root" for BLS verification.
    pub slot_bytes: [u8; 8],

    /// The validator index of the block proposer (serialized as little-endian bytes).
    /// Also part of the "Signing Root".
    pub proposer_bytes: [u8; 8],

    /// The Merkle proof branch connecting the `next_keys_root` to the signed block header.
    /// This proves that the `next_keys_root` is actually part of the state root signed by the committee.
    pub proof: Vec<u8>,

    /// The generalized index (gindex) of the `next_sync_committee` within the Beacon State.
    /// Used to verify the `proof`.
    pub gidx: u32,
}

/// The public output of the SP1 Guest Program.
/// This structure serves as the "public input" for the next step in recursion
/// or for the final on-chain/embedded verifier.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct VerificationOutput {
    /// The Trust Anchor Root.
    /// In a recursive chain A -> B -> C, this will always remain "A" (the start of the chain).
    /// This allows the verifier to check: "Does this proof lead from my Trusted Anchor to a new state?"
    pub current_keys_root: [u8; 32],

    /// The New Trust Root.
    /// The `current_keys_root` for the *next* period.
    /// This becomes the `current_keys_root` for the next proof in the chain.
    pub next_keys_root: [u8; 32],

    /// The Period Number associated with the `next_keys_root`.
    /// Allows the verifier to ensure the update is for the expected period.
    pub next_period: u64,

    /// The SSZ `hash_tree_root` of the `attested_header.beacon` (`BeaconBlockHeader`).
    ///
    /// This is useful for Weak Subjectivity (WS) checks outside the zk-proof: the verifier can
    /// ensure this header root is consistent with an external trusted checkpoint and therefore
    /// treat the proven `next_keys_root` as canonical within the WS window.
    pub attested_header_root: [u8; 32],
}

// Extension trait to help with slice copying in merkle.rs if needed, 
// or just use standard copy_from_slice
pub trait SliceHelper {
    fn copy_from_slice_safe(&mut self, src: &[u8]);
}

impl SliceHelper for [u8] {
    fn copy_from_slice_safe(&mut self, src: &[u8]) {
        if src.len() != self.len() {
            panic!("Slice length mismatch");
        }
        self.copy_from_slice(src);
    }
}

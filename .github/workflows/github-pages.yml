name: Deploy GitHub Pages

on:
  # Run after the main workflow completes successfully
  workflow_run:
    workflows: ["CMake on multiple platforms"]
    types:
      - completed
    branches: [main, dev]

  # Manual trigger option
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for metrics over time

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Download all artifacts
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: cmake.yml
          workflow_conclusion: success
          path: artifacts

      - name: List artifact contents for debugging
        run: |
          echo "Listing all downloaded artifacts:"
          find artifacts -type f | sort

          echo -e "\nDetailed directory structure of artifacts:"
          find artifacts -type d | sort

          echo -e "\nLooking for valgrind-metrics.json files:"
          find artifacts -name "valgrind-metrics.json" | sort

          echo -e "\nLooking for massif-full-report.txt files:"
          find artifacts -name "massif-full-report.txt" | sort

      - name: Create metrics directory structure
        run: |
          mkdir -p _site/metrics
          mkdir -p _site/coverage
          mkdir -p _site/memory-analysis
          mkdir -p _site/static-analysis
          cp -R docs/* _site/ || true  # Copy any static content if it exists

      - name: Process coverage report
        run: |
          # Extract the most recent coverage report
          if [ -d "artifacts/coverage-report" ]; then
            echo "Copying coverage report to _site/coverage/"
            cp -R artifacts/coverage-report/* _site/coverage/
          fi

      - name: Process static analysis reports
        run: |
          # Extract static analysis reports
          if [ -d "artifacts/static-analysis-report" ]; then
            echo "Copying static analysis reports to _site/static-analysis/"
            cp -R artifacts/static-analysis-report/* _site/static-analysis/
            
            # If there's an HTML report, make sure it's accessible
            if [ -d "artifacts/static-analysis-report/report" ]; then
              cp -R artifacts/static-analysis-report/report/* _site/static-analysis/
            fi
            
            # Create a status file to indicate if issues were found
            if [ -f "artifacts/static-analysis-report/analysis_summary.md" ]; then
              cp artifacts/static-analysis-report/analysis_summary.md _site/static-analysis/
              # Check if issues were found
              if grep -q "✅ Static Analysis Results" artifacts/static-analysis-report/analysis_summary.md; then
                echo '{"status": "success", "message": "No issues found"}' > _site/static-analysis/status.json
              else
                echo '{"status": "warning", "message": "Issues found"}' > _site/static-analysis/status.json
              fi
            else
              echo '{"status": "unknown", "message": "No analysis summary found"}' > _site/static-analysis/status.json
            fi
          else
            mkdir -p _site/static-analysis
            echo '{"status": "unknown", "message": "No static analysis reports found"}' > _site/static-analysis/status.json
          fi

      - name: Process memory analysis
        run: |
          # Extract memory analysis reports
          if [ -d "artifacts/memory-analysis" ]; then
            echo "Found memory-analysis artifact, copying to _site/memory-analysis/"
            mkdir -p _site/memory-analysis
            cp -R artifacts/memory-analysis/* _site/memory-analysis/
            echo "Contents of memory-analysis:"
            find artifacts/memory-analysis -type f | sort
          else
            echo "No memory-analysis artifact found"
          fi

          if [ -d "artifacts/memory-analysis-reports" ]; then
            echo "Found memory-analysis-reports artifact, copying to _site/memory-analysis/"
            mkdir -p _site/memory-analysis
            cp -R artifacts/memory-analysis-reports/* _site/memory-analysis/
            echo "Contents of memory-analysis-reports:"
            find artifacts/memory-analysis-reports -type f | sort
          else
            echo "No memory-analysis-reports artifact found"
          fi

          # List resulting files in the site directory for verification
          echo "Final contents of _site/memory-analysis:"
          find _site/memory-analysis -type f | sort 2>/dev/null || echo "No files found in _site/memory-analysis"

      - name: Create metrics history database
        run: |
          # Get commit hash and date
          COMMIT_HASH=$(git rev-parse --short HEAD)
          COMMIT_DATE=$(git show -s --format=%ci $COMMIT_HASH)

          echo "Current commit hash: $COMMIT_HASH"
          echo "Current commit date: $COMMIT_DATE"

          # Create metrics directory if it doesn't exist
          mkdir -p metrics-data

          # Try to fetch existing metrics from the deployed GitHub Pages site
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          GITHUB_PAGES_URL="https://${GITHUB_REPOSITORY_OWNER}.github.io/${REPO_NAME}/metrics/metrics.json"

          echo "Attempting to fetch existing metrics from $GITHUB_PAGES_URL"
          if curl -s -f -o metrics-data/metrics.json "$GITHUB_PAGES_URL"; then
            echo "Successfully fetched existing metrics"
            echo "Content of metrics file:"
            cat metrics-data/metrics.json | jq .
          else
            echo "Could not fetch existing metrics, starting with empty dataset"
            echo "[]" > metrics-data/metrics.json
          fi

          # After attempting to fetch, check if metrics.json is empty or just contains an empty array
          if [ "$(cat metrics-data/metrics.json)" = "[]" ]; then
            echo "metrics.json is empty, using initial_metrics.json as a starting point"
            if [ -f "docs/metrics/initial_metrics.json" ]; then
              cp docs/metrics/initial_metrics.json metrics-data/metrics.json
              echo "Copied initial metrics:"
              cat metrics-data/metrics.json | jq .
            fi
          fi

          # Memory size metrics
          if [ -f "artifacts/memory-analysis-reports/valgrind-metrics.json" ]; then
            echo "Using pre-generated valgrind metrics from memory-analysis-reports artifact"
            cat artifacts/memory-analysis-reports/valgrind-metrics.json
            
            # Extract heap and stack metrics from valgrind-metrics.json
            PEAK_HEAP=$(grep -o '"peak_heap": [^,]*' artifacts/memory-analysis-reports/valgrind-metrics.json | awk '{print $2}')
            PEAK_STACK=$(grep -o '"peak_stack": [^,]*' artifacts/memory-analysis-reports/valgrind-metrics.json | awk '{print $2}')
            
            echo "Extracted peak heap: $PEAK_HEAP"
            echo "Extracted peak stack: $PEAK_STACK"
            
            # Ensure values are not empty
            if [ -z "$PEAK_HEAP" ]; then
              PEAK_HEAP="null"
              echo "Empty PEAK_HEAP, setting to null"
            fi
            if [ -z "$PEAK_STACK" ]; then
              PEAK_STACK="null"
              echo "Empty PEAK_STACK, setting to null"
            fi
          elif [ -f "artifacts/memory-analysis/valgrind-metrics.json" ]; then
            echo "Using pre-generated valgrind metrics from memory-analysis artifact"
            cat artifacts/memory-analysis/valgrind-metrics.json
            
            # Extract heap and stack metrics from valgrind-metrics.json
            PEAK_HEAP=$(grep -o '"peak_heap": [^,]*' artifacts/memory-analysis/valgrind-metrics.json | awk '{print $2}')
            PEAK_STACK=$(grep -o '"peak_stack": [^,]*' artifacts/memory-analysis/valgrind-metrics.json | awk '{print $2}')
            
            echo "Extracted peak heap: $PEAK_HEAP"
            echo "Extracted peak stack: $PEAK_STACK"
            
            # Ensure values are not empty
            if [ -z "$PEAK_HEAP" ]; then
              PEAK_HEAP="null"
              echo "Empty PEAK_HEAP, setting to null"
            fi
            if [ -z "$PEAK_STACK" ]; then
              PEAK_STACK="null"
              echo "Empty PEAK_STACK, setting to null"
            fi
          else
            # Fallback to parsing massif-full-report.txt if valgrind-metrics.json doesn't exist
            if [ -f "artifacts/memory-analysis-reports/massif-full-report.txt" ]; then
              PEAK_HEAP=$(grep "heap_tree=peak" artifacts/memory-analysis-reports/massif-full-report.txt -A 2 | grep "total:" | awk '{print $2}')
              PEAK_STACK=$(grep "mem_stacks_B" artifacts/memory-analysis-reports/massif-full-report.txt | awk -F= '{if($2>max) max=$2} END{print max}')
              echo "Extracted peak heap: $PEAK_HEAP, peak stack: $PEAK_STACK"
              
              # Ensure values are not empty
              if [ -z "$PEAK_HEAP" ]; then
                PEAK_HEAP="null"
                echo "Empty PEAK_HEAP, setting to null"
              fi
              if [ -z "$PEAK_STACK" ]; then
                PEAK_STACK="null"
                echo "Empty PEAK_STACK, setting to null"
              fi
            elif [ -f "artifacts/memory-analysis/massif-full-report.txt" ]; then
              PEAK_HEAP=$(grep "heap_tree=peak" artifacts/memory-analysis/massif-full-report.txt -A 2 | grep "total:" | awk '{print $2}')
              PEAK_STACK=$(grep "mem_stacks_B" artifacts/memory-analysis/massif-full-report.txt | awk -F= '{if($2>max) max=$2} END{print max}')
              echo "Extracted peak heap: $PEAK_HEAP, peak stack: $PEAK_STACK"
              
              # Ensure values are not empty
              if [ -z "$PEAK_HEAP" ]; then
                PEAK_HEAP="null"
                echo "Empty PEAK_HEAP, setting to null"
              fi
              if [ -z "$PEAK_STACK" ]; then
                PEAK_STACK="null"
                echo "Empty PEAK_STACK, setting to null"
              fi
            else
              echo "Warning: valgrind-metrics.json and massif-full-report.txt not found in either artifact"
              PEAK_HEAP="null"
              PEAK_STACK="null"
            fi
          fi

          # Executable size
          if [ -d "artifacts/memory-analysis" ]; then
            # Use the pre-generated metrics.json file from build_embedded job
            if [ -f "artifacts/memory-analysis/metrics.json" ]; then
              echo "Using pre-generated metrics from build_embedded job"
              cat artifacts/memory-analysis/metrics.json
              
              # Extract embedded metrics from metrics.json
              TEXT_SIZE=$(grep -o '"text_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              DATA_SIZE=$(grep -o '"data_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              BSS_SIZE=$(grep -o '"bss_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              TOTAL_SIZE=$(grep -o '"total_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              
              echo "Extracted text size: $TEXT_SIZE"
              echo "Extracted data size: $DATA_SIZE"
              echo "Extracted BSS size: $BSS_SIZE"
              echo "Extracted total size: $TOTAL_SIZE"
              
              # For backward compatibility, still extract executable size from summary file
              EXEC_SIZE=$(grep "Executable" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
              echo "Extracted executable size: $EXEC_SIZE"
              
              # Ensure EXEC_SIZE is not empty
              if [ -z "$EXEC_SIZE" ]; then
                EXEC_SIZE="null"
                echo "Empty EXEC_SIZE, setting to null"
              fi
            else
              # Fallback to parsing size_summary.txt
              echo "Pre-generated metrics.json not found, parsing size_summary.txt"
              if [ -f "artifacts/memory-analysis/size_summary.txt" ]; then
                cat artifacts/memory-analysis/size_summary.txt
                EXEC_SIZE=$(grep "Executable" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                TEXT_SIZE=$(grep "Text" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                DATA_SIZE=$(grep "Data" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                BSS_SIZE=$(grep "BSS" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                TOTAL_SIZE=$(grep "Total" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                
                echo "Extracted text size: $TEXT_SIZE"
                echo "Extracted data size: $DATA_SIZE"
                echo "Extracted BSS size: $BSS_SIZE"
                echo "Extracted total size: $TOTAL_SIZE"
                echo "Extracted executable size: $EXEC_SIZE"
                
                # Ensure values are not empty
                if [ -z "$EXEC_SIZE" ]; then
                  EXEC_SIZE="null"
                  echo "Empty EXEC_SIZE, setting to null"
                fi
                if [ -z "$TEXT_SIZE" ]; then
                  TEXT_SIZE="null"
                  echo "Empty TEXT_SIZE, setting to null"
                fi
                if [ -z "$DATA_SIZE" ]; then
                  DATA_SIZE="null"
                  echo "Empty DATA_SIZE, setting to null"
                fi
                if [ -z "$BSS_SIZE" ]; then
                  BSS_SIZE="null"
                  echo "Empty BSS_SIZE, setting to null"
                fi
                if [ -z "$TOTAL_SIZE" ]; then
                  TOTAL_SIZE="null"
                  echo "Empty TOTAL_SIZE, setting to null"
                fi
              else
                echo "Warning: size_summary.txt not found"
                EXEC_SIZE="null"
                TEXT_SIZE="null"
                DATA_SIZE="null"
                BSS_SIZE="null"
                TOTAL_SIZE="null"
              fi
            fi
          else
            echo "Warning: memory-analysis directory not found"
            EXEC_SIZE="null"
            TEXT_SIZE="null"
            DATA_SIZE="null"
            BSS_SIZE="null"
            TOTAL_SIZE="null"
          fi

          # Code coverage metrics
          if [ -f "artifacts/coverage-report/coverage_summary.txt" ]; then
            cat artifacts/coverage-report/coverage_summary.txt
            # Try different patterns to extract coverage percentage
            if grep -q "Total coverage:" artifacts/coverage-report/coverage_summary.txt; then
              TOTAL_COVERAGE=$(grep "Total coverage:" artifacts/coverage-report/coverage_summary.txt | grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' | sed 's/%//g')
            elif grep -q "Total" artifacts/coverage-report/coverage_summary.txt; then
              TOTAL_COVERAGE=$(grep "Total" artifacts/coverage-report/coverage_summary.txt | grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' | sed 's/%//g')
            else
              # Try to extract from the last line with a percentage
              TOTAL_COVERAGE=$(grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' artifacts/coverage-report/coverage_summary.txt | tail -1 | sed 's/%//g')
            fi
            
            echo "Extracted coverage: $TOTAL_COVERAGE"
            # Ensure TOTAL_COVERAGE is not empty
            if [ -z "$TOTAL_COVERAGE" ]; then
              TOTAL_COVERAGE="null"
              echo "Empty TOTAL_COVERAGE, setting to null"
            fi
          else
            echo "Warning: coverage_summary.txt not found"
            TOTAL_COVERAGE="null"
          fi

          # Check for static analysis results
          if [ -f "artifacts/static-analysis-report/analysis_summary.md" ]; then
            cat artifacts/static-analysis-report/analysis_summary.md
            if grep -q "✅ Static Analysis Results" artifacts/static-analysis-report/analysis_summary.md; then
              STATIC_ANALYSIS="pass"
            else
              STATIC_ANALYSIS="fail"
            fi
            echo "Static analysis status: $STATIC_ANALYSIS"
          else
            echo "Warning: analysis_summary.md not found"
            STATIC_ANALYSIS="null"
          fi

          # Validate all metrics values to ensure they are valid for JSON
          # For each value, if it's empty, set it to "null"
          [ -z "$PEAK_HEAP" ] && PEAK_HEAP="null"
          [ -z "$PEAK_STACK" ] && PEAK_STACK="null"
          [ -z "$TEXT_SIZE" ] && TEXT_SIZE="null"
          [ -z "$DATA_SIZE" ] && DATA_SIZE="null"
          [ -z "$BSS_SIZE" ] && BSS_SIZE="null"
          [ -z "$TOTAL_SIZE" ] && TOTAL_SIZE="null"
          [ -z "$EXEC_SIZE" ] && EXEC_SIZE="null"
          [ -z "$TOTAL_COVERAGE" ] && TOTAL_COVERAGE="null"
          [ -z "$STATIC_ANALYSIS" ] && STATIC_ANALYSIS="null"

          # Create JSON using jq for proper escaping and formatting
          NEW_METRICS=$(jq -n \
              --arg commit "$COMMIT_HASH" \
              --arg date "$COMMIT_DATE" \
              --argjson heap_size "$([ "$PEAK_HEAP" = "null" ] && echo null || echo $PEAK_HEAP)" \
              --argjson stack_size "$([ "$PEAK_STACK" = "null" ] && echo null || echo $PEAK_STACK)" \
              --argjson executable_size "$([ "$EXEC_SIZE" = "null" ] && echo null || echo $EXEC_SIZE)" \
              --argjson text_size "$([ "$TEXT_SIZE" = "null" ] && echo null || echo $TEXT_SIZE)" \
              --argjson data_size "$([ "$DATA_SIZE" = "null" ] && echo null || echo $DATA_SIZE)" \
              --argjson bss_size "$([ "$BSS_SIZE" = "null" ] && echo null || echo $BSS_SIZE)" \
              --argjson total_size "$([ "$TOTAL_SIZE" = "null" ] && echo null || echo $TOTAL_SIZE)" \
              --argjson coverage "$([ "$TOTAL_COVERAGE" = "null" ] && echo null || echo $TOTAL_COVERAGE)" \
              --arg static_analysis "$STATIC_ANALYSIS" \
              '{commit: $commit, date: $date, heap_size: $heap_size, stack_size: $stack_size, 
                executable_size: $executable_size, text_size: $text_size, data_size: $data_size, 
                bss_size: $bss_size, total_size: $total_size, coverage: $coverage, 
                static_analysis: $static_analysis}')

          echo "New metrics entry:"
          echo $NEW_METRICS | jq .

          # More robust check if this commit is already in the metrics file
          if jq -e ".[] | select(.commit == \"$COMMIT_HASH\")" metrics-data/metrics.json > /dev/null; then
            echo "Metrics for commit $COMMIT_HASH already exist, skipping"
          else
            echo "Adding new metrics for commit $COMMIT_HASH"
            # Add new metrics to the JSON file
            jq ". + [$NEW_METRICS]" metrics-data/metrics.json > temp.json && mv temp.json metrics-data/metrics.json
            echo "Updated metrics file:"
            cat metrics-data/metrics.json | jq .
          fi

          # Special handling for development mode or manual triggers:
          # For dev branch or manual workflow dispatch, always add a timestamp-based entry for testing
          if [[ "$GITHUB_REF" == *"dev"* || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Development mode or manual trigger detected, adding test metrics entry"
            # Create a timestamped test entry
            TIMESTAMP=$(date +%s)
            TEST_COMMIT="test-$TIMESTAMP"
            TEST_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            
            # Use the actual metric values but with a different commit hash
            TEST_METRICS=$(jq -n \
              --arg commit "$TEST_COMMIT" \
              --arg date "$TEST_DATE" \
              --argjson heap_size "$([ "$PEAK_HEAP" = "null" ] && echo null || echo $PEAK_HEAP)" \
              --argjson stack_size "$([ "$PEAK_STACK" = "null" ] && echo null || echo $PEAK_STACK)" \
              --argjson executable_size "$([ "$EXEC_SIZE" = "null" ] && echo null || echo $EXEC_SIZE)" \
              --argjson text_size "$([ "$TEXT_SIZE" = "null" ] && echo null || echo $TEXT_SIZE)" \
              --argjson data_size "$([ "$DATA_SIZE" = "null" ] && echo null || echo $DATA_SIZE)" \
              --argjson bss_size "$([ "$BSS_SIZE" = "null" ] && echo null || echo $BSS_SIZE)" \
              --argjson total_size "$([ "$TOTAL_SIZE" = "null" ] && echo null || echo $TOTAL_SIZE)" \
              --argjson coverage "$([ "$TOTAL_COVERAGE" = "null" ] && echo null || echo $TOTAL_COVERAGE)" \
              --arg static_analysis "$STATIC_ANALYSIS" \
              '{commit: $commit, date: $date, heap_size: $heap_size, stack_size: $stack_size, 
                executable_size: $executable_size, text_size: $text_size, data_size: $data_size, 
                bss_size: $bss_size, total_size: $total_size, coverage: $coverage, 
                static_analysis: $static_analysis}')
            
            echo "Adding test metrics entry for development:"
            echo $TEST_METRICS | jq .
            
            # Add the test metrics to the JSON file
            jq ". + [$TEST_METRICS]" metrics-data/metrics.json > temp.json && mv temp.json metrics-data/metrics.json
          fi

          # Copy metrics data to site
          cp metrics-data/metrics.json _site/metrics/

      - name: Create visualization pages
        run: |
          # Create index.html
          cat > _site/index.html << 'EOL'
          <!DOCTYPE html>
          <html lang="en" data-bs-theme="dark">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Colibri Project Metrics</title>
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
              body {
                background-color: #121212;
                color: #e0e0e0;
              }
              .card {
                background-color: #1e1e1e;
                border-color: #333;
              }
              .card-header {
                background-color: #252525;
                border-color: #333;
              }
              .list-group-item {
                background-color: #1e1e1e;
                border-color: #333;
                color: #e0e0e0;
              }
              .list-group-item a {
                color: #8ab4f8;
              }
              .btn-outline-primary {
                color: #8ab4f8;
                border-color: #8ab4f8;
              }
              .btn-outline-primary:hover {
                background-color: #8ab4f8;
                color: #121212;
              }
              .theme-toggle {
                position: absolute;
                top: 10px;
                right: 20px;
                cursor: pointer;
                font-size: 1.2rem;
              }
            </style>
          </head>
          <body>
            <div class="container mt-5">
              <div class="theme-toggle" id="themeToggle">🌞</div>
              <h1 class="mb-4">Colibri Project Metrics</h1>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Memory Usage Over Time</h5>
                    </div>
                    <div class="card-body">
                      <canvas id="memoryChart"></canvas>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Code Coverage Over Time</h5>
                    </div>
                    <div class="card-body">
                      <canvas id="coverageChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Embedded Metrics Over Time</h5>
                    </div>
                    <div class="card-body">
                      <canvas id="embeddedMetricsChart"></canvas>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Latest Static Analysis</h5>
                    </div>
                    <div class="card-body">
                      <div id="staticAnalysisStatus" class="alert" role="alert">
                        Loading static analysis status...
                      </div>
                      <div class="mt-3">
                        <a href="./static-analysis/index.html" class="btn btn-outline-primary" id="viewStaticAnalysisBtn">View Static Analysis Report</a>
                      </div>
                      <div class="mt-3">
                        <canvas id="staticAnalysisChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Latest Reports</h5>
                    </div>
                    <div class="card-body">
                      <ul class="list-group">
                        <li class="list-group-item">
                          <a href="./coverage/index.html">Coverage Report</a>
                        </li>
                        <li class="list-group-item">
                          <a href="./memory-analysis/massif-full-report.txt">Memory Analysis Report</a>
                        </li>
                        <li class="list-group-item">
                          <a href="./static-analysis/analysis_summary.md">Static Analysis Summary</a>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <script>
              // Theme toggle functionality
              const themeToggle = document.getElementById('themeToggle');
              themeToggle.addEventListener('click', () => {
                const htmlElement = document.documentElement;
                if (htmlElement.getAttribute('data-bs-theme') === 'dark') {
                  htmlElement.setAttribute('data-bs-theme', 'light');
                  document.body.style.backgroundColor = '#ffffff';
                  document.body.style.color = '#212529';
                  themeToggle.textContent = '🌙';
                  // Update all cards and list items
                  document.querySelectorAll('.card, .list-group-item').forEach(el => {
                    el.style.backgroundColor = '';
                    el.style.borderColor = '';
                  });
                  document.querySelectorAll('.card-header').forEach(el => {
                    el.style.backgroundColor = '';
                    el.style.borderColor = '';
                  });
                  document.querySelectorAll('.list-group-item').forEach(el => {
                    el.style.color = '';
                  });
                  document.querySelectorAll('.list-group-item a').forEach(el => {
                    el.style.color = '';
                  });
                  document.querySelectorAll('.btn-outline-primary').forEach(el => {
                    el.style.color = '';
                    el.style.borderColor = '';
                  });
                } else {
                  htmlElement.setAttribute('data-bs-theme', 'dark');
                  document.body.style.backgroundColor = '#121212';
                  document.body.style.color = '#e0e0e0';
                  themeToggle.textContent = '🌞';
                  // Update all cards and list items
                  document.querySelectorAll('.card, .list-group-item').forEach(el => {
                    el.style.backgroundColor = '#1e1e1e';
                    el.style.borderColor = '#333';
                  });
                  document.querySelectorAll('.card-header').forEach(el => {
                    el.style.backgroundColor = '#252525';
                    el.style.borderColor = '#333';
                  });
                  document.querySelectorAll('.list-group-item').forEach(el => {
                    el.style.color = '#e0e0e0';
                  });
                  document.querySelectorAll('.list-group-item a').forEach(el => {
                    el.style.color = '#8ab4f8';
                  });
                  document.querySelectorAll('.btn-outline-primary').forEach(el => {
                    el.style.color = '#8ab4f8';
                    el.style.borderColor = '#8ab4f8';
                  });
                }
                // Re-render charts with appropriate colors
                updateChartsForTheme();
              });
              
              // Function to update chart colors based on theme
              function updateChartsForTheme() {
                // This would be called when theme changes and after charts are initialized
                // Not implemented fully here as it would require storing chart instances
              }
              
              // Define chart colors for dark mode
              const isDarkMode = document.documentElement.getAttribute('data-bs-theme') === 'dark';
              const colors = {
                text: isDarkMode ? 'rgba(255, 159, 64, 0.8)' : 'rgba(255, 159, 64, 1)',
                data: isDarkMode ? 'rgba(75, 192, 192, 0.8)' : 'rgba(75, 192, 192, 1)',
                bss: isDarkMode ? 'rgba(153, 102, 255, 0.8)' : 'rgba(153, 102, 255, 1)',
                total: isDarkMode ? 'rgba(54, 162, 235, 0.8)' : 'rgba(54, 162, 235, 1)',
                heap: isDarkMode ? 'rgba(75, 192, 192, 0.8)' : 'rgba(75, 192, 192, 1)',
                stack: isDarkMode ? 'rgba(153, 102, 255, 0.8)' : 'rgba(153, 102, 255, 1)',
                coverage: isDarkMode ? 'rgba(255, 99, 132, 0.8)' : 'rgba(255, 99, 132, 1)',
                staticAnalysis: isDarkMode ? 'rgba(54, 162, 235, 0.8)' : 'rgba(54, 162, 235, 1)'
              };
              
              // Fetch the metrics data
              fetch('./metrics/metrics.json')
                .then(response => response.json())
                .then(data => {
                  // Sort data by date
                  data.sort((a, b) => new Date(a.date) - new Date(b.date));
                  
                  // Format dates for display
                  const dates = data.map(entry => {
                    const date = new Date(entry.date);
                    return date.toLocaleDateString();
                  });
                  
                  // Extract metrics
                  const heapSizes = data.map(entry => entry.heap_size === null ? null : 
                    typeof entry.heap_size === 'string' ? parseFloat(entry.heap_size) / 1024 : entry.heap_size / 1024); // Convert to KB
                  const stackSizes = data.map(entry => entry.stack_size === null ? null : 
                    typeof entry.stack_size === 'string' ? parseFloat(entry.stack_size) / 1024 : entry.stack_size / 1024); // Convert to KB
                  const coverageValues = data.map(entry => entry.coverage);
                  
                  // Extract embedded metrics
                  const textSizes = data.map(entry => entry.text_size === null ? null : 
                    typeof entry.text_size === 'string' ? parseFloat(entry.text_size) : entry.text_size);
                  const dataSizes = data.map(entry => entry.data_size === null ? null : 
                    typeof entry.data_size === 'string' ? parseFloat(entry.data_size) : entry.data_size);
                  const bssSizes = data.map(entry => entry.bss_size === null ? null : 
                    typeof entry.bss_size === 'string' ? parseFloat(entry.bss_size) : entry.bss_size);
                  const totalSizes = data.map(entry => entry.total_size === null ? null : 
                    typeof entry.total_size === 'string' ? parseFloat(entry.total_size) : entry.total_size);
                  
                  // Create memory chart
                  const memoryCtx = document.getElementById('memoryChart').getContext('2d');
                  new Chart(memoryCtx, {
                    type: 'line',
                    data: {
                      labels: dates,
                      datasets: [
                        {
                          label: 'Peak Heap (KB)',
                          data: heapSizes,
                          borderColor: colors.heap,
                          backgroundColor: isDarkMode ? 'rgba(75, 192, 192, 0.1)' : 'rgba(75, 192, 192, 0.2)',
                          tension: 0.1
                        },
                        {
                          label: 'Peak Stack (KB)',
                          data: stackSizes,
                          borderColor: colors.stack,
                          backgroundColor: isDarkMode ? 'rgba(153, 102, 255, 0.1)' : 'rgba(153, 102, 255, 0.2)',
                          tension: 0.1
                        }
                      ]
                    },
                    options: {
                      scales: {
                        y: {
                          beginAtZero: true,
                          title: {
                            display: true,
                            text: 'Size (KB)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        }
                      }
                    }
                  });
                  
                  // Create coverage chart
                  const coverageCtx = document.getElementById('coverageChart').getContext('2d');
                  new Chart(coverageCtx, {
                    type: 'line',
                    data: {
                      labels: dates,
                      datasets: [{
                        label: 'Code Coverage (%)',
                        data: coverageValues,
                        borderColor: colors.coverage,
                        backgroundColor: isDarkMode ? 'rgba(255, 99, 132, 0.1)' : 'rgba(255, 99, 132, 0.2)',
                        tension: 0.1
                      }]
                    },
                    options: {
                      scales: {
                        y: {
                          beginAtZero: true,
                          max: 100,
                          title: {
                            display: true,
                            text: 'Coverage (%)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        }
                      }
                    }
                  });
                  
                  // Create embedded metrics chart (stacked)
                  const embeddedCtx = document.getElementById('embeddedMetricsChart').getContext('2d');
                  new Chart(embeddedCtx, {
                    type: 'bar', // Changed to bar for stacking
                    data: {
                      labels: dates,
                      datasets: [
                        {
                          label: 'Text Size (KB)',
                          data: textSizes,
                          backgroundColor: colors.text,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'Data Size (KB)',
                          data: dataSizes,
                          backgroundColor: colors.data,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'BSS Size (KB)',
                          data: bssSizes,
                          backgroundColor: colors.bss,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'Total Size (KB)',
                          data: totalSizes,
                          type: 'line',
                          borderColor: colors.total,
                          backgroundColor: 'transparent',
                          borderWidth: 2,
                          tension: 0.1,
                          pointRadius: 3,
                          pointBackgroundColor: colors.total
                        }
                      ]
                    },
                    options: {
                      scales: {
                        y: {
                          stacked: true, // Enable stacking
                          beginAtZero: true,
                          title: {
                            display: true,
                            text: 'Size (KB)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          stacked: true, // Enable stacking
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        },
                        tooltip: {
                          callbacks: {
                            footer: function(tooltipItems) {
                              // Add the sum to the tooltip
                              let sum = 0;
                              tooltipItems.forEach(function(tooltipItem) {
                                // Exclude the Total Size dataset which is index 3
                                if (tooltipItem.datasetIndex < 3) {
                                  sum += tooltipItem.parsed.y;
                                }
                              });
                              return 'Sum: ' + sum.toFixed(2) + ' KB';
                            }
                          }
                        }
                      }
                    }
                  });
                  
                  // Process static analysis results for chart
                  const staticResults = data.map(entry => {
                    if (!entry.static_analysis || entry.static_analysis === "null") {
                      return null;
                    }
                    return entry.static_analysis === "pass" ? 1 : 0;
                  });
                  
                  // Create static analysis chart (only if we have data)
                  if (staticResults.some(result => result !== null)) {
                    const staticAnalysisCtx = document.getElementById('staticAnalysisChart').getContext('2d');
                    new Chart(staticAnalysisCtx, {
                      type: 'line',
                      data: {
                        labels: dates,
                        datasets: [{
                          label: 'Static Analysis Status',
                          data: staticResults,
                          borderColor: colors.staticAnalysis,
                          backgroundColor: isDarkMode ? 'rgba(54, 162, 235, 0.1)' : 'rgba(54, 162, 235, 0.2)',
                          tension: 0.1,
                          stepped: true
                        }]
                      },
                      options: {
                        scales: {
                          y: {
                            min: 0,
                            max: 1,
                            ticks: {
                              stepSize: 1,
                              callback: function(value) {
                                return value === 1 ? 'Pass' : 'Fail';
                              },
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            title: {
                              display: true,
                              text: 'Status',
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            grid: {
                              color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                          },
                          x: {
                            ticks: {
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            grid: {
                              color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                          }
                        },
                        plugins: {
                          legend: {
                            labels: {
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            }
                          }
                        }
                      }
                    });
                  }
                  
                  // Update latest status widget based on most recent data
                  const latestData = [...data].sort((a, b) => new Date(b.date) - new Date(a.date))[0];
                  const statusElement = document.getElementById('staticAnalysisStatus');
                  
                  if (latestData && latestData.static_analysis) {
                    if (latestData.static_analysis === "pass") {
                      statusElement.className = 'alert alert-success';
                      statusElement.textContent = '✅ Latest static analysis passed with no issues';
                    } else if (latestData.static_analysis === "fail") {
                      statusElement.className = 'alert alert-warning';
                      statusElement.textContent = '⚠️ Latest static analysis found issues';
                    } else {
                      statusElement.className = 'alert alert-secondary';
                      statusElement.textContent = 'ℹ️ Static analysis status unknown';
                    }
                  }
                })
                .catch(error => console.error('Error loading metrics:', error));
                
              // Fetch static analysis status
              fetch('./static-analysis/status.json')
                .then(response => response.json())
                .then(data => {
                  const statusElement = document.getElementById('staticAnalysisStatus');
                  const reportBtn = document.getElementById('viewStaticAnalysisBtn');
                  
                  if (data.status === 'success') {
                    statusElement.className = 'alert alert-success';
                    statusElement.textContent = '✅ No static analysis issues found';
                  } else if (data.status === 'warning') {
                    statusElement.className = 'alert alert-warning';
                    statusElement.textContent = '⚠️ Static analysis issues found';
                  } else {
                    statusElement.className = 'alert alert-secondary';
                    statusElement.textContent = 'ℹ️ ' + data.message;
                  }
                  
                  // Update report button href based on available files
                  fetch('./static-analysis/index.html')
                    .then(() => {
                      // HTML report exists, keep default link
                    })
                    .catch(() => {
                      // HTML report doesn't exist, update button to analysis summary
                      reportBtn.href = './static-analysis/analysis_summary.md';
                    });
                })
                .catch(error => {
                  // If static analysis status fetch fails, metrics will still provide the info
                  console.log('Static analysis status file not available, using metrics data instead');
                });
            </script>
          </body>
          </html>
          EOL

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

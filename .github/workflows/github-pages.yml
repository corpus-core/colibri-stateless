name: Deploy GitHub Pages

on:
  # Run after the main workflow completes successfully
  workflow_run:
    workflows: ["CMake on multiple platforms"]
    types:
      - completed
    branches: [main, dev]

  # Manual trigger option
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for metrics

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Download all artifacts
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: cmake.yml
          workflow_conclusion: success
          path: artifacts

      - name: List artifact contents for debugging
        run: |
          echo "Listing all downloaded artifacts:"
          find artifacts -type f | sort

          echo -e "\nDetailed directory structure of artifacts:"
          find artifacts -type d | sort

          echo -e "\nLooking for valgrind-metrics.json files:"
          find artifacts -name "valgrind-metrics.json" | sort

          echo -e "\nLooking for massif-full-report.txt files:"
          find artifacts -name "massif-full-report.txt" | sort

      - name: Create metrics directory structure
        run: |
          mkdir -p _site/metrics
          mkdir -p _site/coverage
          mkdir -p _site/memory-analysis
          mkdir -p _site/static-analysis
          cp -R docs/* _site/ || true  # Copy any static content if it exists

      - name: Process coverage report
        run: |
          # Extract the most recent coverage report
          if [ -d "artifacts/coverage-report" ]; then
            echo "Copying coverage report to _site/coverage/"
            cp -R artifacts/coverage-report/* _site/coverage/
          fi

      - name: Process static analysis reports
        run: |
          # Extract static analysis reports
          if [ -d "artifacts/static-analysis-report" ]; then
            echo "Copying static analysis reports to _site/static-analysis/"
            cp -R artifacts/static-analysis-report/* _site/static-analysis/
            
            # If there's an HTML report, make sure it's accessible
            if [ -d "artifacts/static-analysis-report/report" ]; then
              cp -R artifacts/static-analysis-report/report/* _site/static-analysis/
            fi
            
            # Create a status file to indicate if issues were found
            if [ -f "artifacts/static-analysis-report/analysis_summary.md" ]; then
              cp artifacts/static-analysis-report/analysis_summary.md _site/static-analysis/
              # Check if issues were found
              if grep -q "✅ Static Analysis Results" artifacts/static-analysis-report/analysis_summary.md; then
                echo '{"status": "success", "message": "No issues found"}' > _site/static-analysis/status.json
              else
                echo '{"status": "warning", "message": "Issues found"}' > _site/static-analysis/status.json
              fi
            else
              echo '{"status": "unknown", "message": "No analysis summary found"}' > _site/static-analysis/status.json
            fi
          else
            mkdir -p _site/static-analysis
            echo '{"status": "unknown", "message": "No static analysis reports found"}' > _site/static-analysis/status.json
          fi

      - name: Process memory analysis
        run: |
          # Check for memory analysis artifacts
          if [ -d "artifacts/memory-analysis-reports" ]; then
            echo "Found memory-analysis-reports artifact directory:"
            ls -la artifacts/memory-analysis-reports
            
            # Copy all memory analysis reports to site directory
            mkdir -p _site/memory-analysis
            cp -R artifacts/memory-analysis-reports/* _site/memory-analysis/ || true
            
            # If massif-full-report.txt exists, create an application-focused version
            if [ -f "_site/memory-analysis/massif-full-report.txt" ]; then
              echo "Creating application-specific heap report from massif-full-report.txt"
              
              # Copy the AWK script to extract application heap usage
              cp .github/extract-app-heap.awk "_site/memory-analysis/extract-app-heap.awk"
              chmod +x "_site/memory-analysis/extract-app-heap.awk"
              
              # Debug: Check if the AWK script was copied properly
              echo "Checking AWK script:"
              ls -la "_site/memory-analysis/extract-app-heap.awk"
              head -n 5 "_site/memory-analysis/extract-app-heap.awk"
              
              # Debug: Check the first few lines of the massif report
              echo "Checking massif report format:"
              head -n 10 "_site/memory-analysis/massif-full-report.txt"
              
              # Run the AWK script
              echo "Running AWK script..."
              if ! awk -f "_site/memory-analysis/extract-app-heap.awk" "_site/memory-analysis/massif-full-report.txt" > "_site/memory-analysis/app-heap-report.txt" 2>"_site/memory-analysis/awk-error.log"; then
                echo "AWK script failed. Error output:"
                cat "_site/memory-analysis/awk-error.log"
                # Create an empty app-heap-report.txt to allow the workflow to continue
                echo "# Fallback: Creating empty app heap report" > "_site/memory-analysis/app-heap-report.txt"
                echo "heap_tree=peak" >> "_site/memory-analysis/app-heap-report.txt"
                echo "n1: 0 (heap allocation functions) malloc/new/new[], --alloc-fns, etc." >> "_site/memory-analysis/app-heap-report.txt"
                echo " n0: 0 in 0 places, all below massif's threshold" >> "_site/memory-analysis/app-heap-report.txt"
              else
                echo "AWK script completed successfully"
              fi
              
              # Also extract peak heap sizes that are actually from the application
              echo "Extracting peak heap sizes from app-heap-report.txt"
              if ! grep -A 10 "heap_tree=peak" "_site/memory-analysis/app-heap-report.txt" | grep -m1 -A3 '[0-9]\.[0-9]\+%\|[0-9]%' > "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null; then
                # Try alternate format for matching percentages
                grep -A 10 "heap_tree=peak" "_site/memory-analysis/app-heap-report.txt" | grep -m1 -A3 'n[0-9]\+:' > "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null || true
              fi
              
              # Make sure app-peak-heap.txt exists even if empty
              touch "_site/memory-analysis/app-peak-heap.txt"
              
              # Show extracted peak heap information
              echo "Extracted peak heap information:"
              cat "_site/memory-analysis/app-peak-heap.txt" || echo "No peak heap information found"
              
              # Process application heap metrics
              # Try different patterns to extract the peak heap value
              APP_PEAK_HEAP=$(grep "total:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | awk '{print $2}' | tr -d ',' || echo "")
              
              # If that didn't work, try another common format
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=$(grep -E "n[0-9]+:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | head -1 | awk '{print $2}' | tr -d ',' || echo "")
              fi
              
              # If still empty, try looking for any number
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=$(grep -Eo '[0-9]+' "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | head -1 || echo "0")
              fi
              
              # Convert to integer if found, otherwise use 0
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=0
                echo "No application peak heap value found, defaulting to 0"
              else
                # Remove commas if present
                APP_PEAK_HEAP=$(echo $APP_PEAK_HEAP | tr -d ',')
                echo "Found application peak heap usage: $APP_PEAK_HEAP bytes"
              fi
              
              # Create or update valgrind-metrics.json with app heap
              if [ -f "_site/memory-analysis/valgrind-metrics.json" ]; then
                # Update existing file
                TMP_JSON=$(mktemp)
                jq --arg app_heap "$APP_PEAK_HEAP" '. + {"app_heap": $app_heap|tonumber}' "_site/memory-analysis/valgrind-metrics.json" > "$TMP_JSON"
                mv "$TMP_JSON" "_site/memory-analysis/valgrind-metrics.json"
              else
                # Create new file
                echo "{\"peak_heap\": 0, \"peak_stack\": 0, \"app_heap\": $APP_PEAK_HEAP}" > "_site/memory-analysis/valgrind-metrics.json"
              fi
              
              echo "Updated valgrind metrics with application heap usage:"
              cat "_site/memory-analysis/valgrind-metrics.json"
            fi
          else
            echo "No memory-analysis-reports artifact found"
          fi

          # Check for standard memory analysis artifacts as fallback
          if [ -d "artifacts/memory-analysis" ]; then
            echo "Found memory-analysis artifact directory:"
            ls -la artifacts/memory-analysis
            
            # Copy memory analysis files if they don't already exist
            mkdir -p _site/memory-analysis
            cp -R artifacts/memory-analysis/* _site/memory-analysis/ || true
            
            # If there's a massif-full-report.txt and we haven't processed it yet
            if [ -f "_site/memory-analysis/massif-full-report.txt" ] && [ ! -f "_site/memory-analysis/app-heap-report.txt" ]; then
              echo "Creating application-specific heap report from memory-analysis artifact"
              
              # Check if we need to fall back to extracting from massif report
              if [ -n "$FALL_BACK_TO_MASSIF" ]; then
                if [ -f "_site/memory-analysis/massif-full-report.txt" ]; then
                  echo "Falling back to extracting heap metrics from massif-full-report.txt"
                  # Try to reuse the AWK script if it exists in both artifacts
                  if [ ! -f "_site/memory-analysis/extract-app-heap.awk" ]; then
                    cp .github/extract-app-heap.awk "_site/memory-analysis/extract-app-heap.awk"
                    chmod +x "_site/memory-analysis/extract-app-heap.awk"
                  fi
                fi
              fi
              
              # Run the AWK script
              echo "Running AWK script..."
              if ! awk -f "_site/memory-analysis/extract-app-heap.awk" "_site/memory-analysis/massif-full-report.txt" > "_site/memory-analysis/app-heap-report.txt" 2>"_site/memory-analysis/awk-error.log"; then
                echo "AWK script failed. Error output:"
                cat "_site/memory-analysis/awk-error.log"
                # Create an empty app-heap-report.txt to allow the workflow to continue
                echo "# Fallback: Creating empty app heap report" > "_site/memory-analysis/app-heap-report.txt"
                echo "heap_tree=peak" >> "_site/memory-analysis/app-heap-report.txt"
                echo "n1: 0 (heap allocation functions) malloc/new/new[], --alloc-fns, etc." >> "_site/memory-analysis/app-heap-report.txt"
                echo " n0: 0 in 0 places, all below massif's threshold" >> "_site/memory-analysis/app-heap-report.txt"
              else
                echo "AWK script completed successfully"
              fi
              
              # Also extract peak heap sizes that are actually from the application
              echo "Extracting peak heap sizes from app-heap-report.txt"
              if ! grep -A 10 "heap_tree=peak" "_site/memory-analysis/app-heap-report.txt" | grep -m1 -A3 '[0-9]\.[0-9]\+%\|[0-9]%' > "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null; then
                # Try alternate format for matching percentages
                grep -A 10 "heap_tree=peak" "_site/memory-analysis/app-heap-report.txt" | grep -m1 -A3 'n[0-9]\+:' > "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null || true
              fi
              
              # Make sure app-peak-heap.txt exists even if empty
              touch "_site/memory-analysis/app-peak-heap.txt"
              
              # Show extracted peak heap information
              echo "Extracted peak heap information:"
              cat "_site/memory-analysis/app-peak-heap.txt" || echo "No peak heap information found"
              
              # Process application heap metrics
              # Try different patterns to extract the peak heap value
              APP_PEAK_HEAP=$(grep "total:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | awk '{print $2}' | tr -d ',' || echo "")
              
              # If that didn't work, try another common format
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=$(grep -E "n[0-9]+:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | head -1 | awk '{print $2}' | tr -d ',' || echo "")
              fi
              
              # If still empty, try looking for any number
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=$(grep -Eo '[0-9]+' "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | head -1 || echo "0")
              fi
              
              # Convert to integer if found, otherwise use 0
              if [ -z "$APP_PEAK_HEAP" ]; then
                APP_PEAK_HEAP=0
                echo "No application peak heap value found, defaulting to 0"
              else
                # Remove commas if present
                APP_PEAK_HEAP=$(echo $APP_PEAK_HEAP | tr -d ',')
                echo "Found application peak heap usage: $APP_PEAK_HEAP bytes"
              fi
              
              echo "Application peak heap usage: $APP_PEAK_HEAP bytes"
              
              # Create or update valgrind-metrics.json with app heap
              if [ -f "_site/memory-analysis/valgrind-metrics.json" ]; then
                # Update existing file
                TMP_JSON=$(mktemp)
                jq --arg app_heap "$APP_PEAK_HEAP" '. + {"app_heap": $app_heap|tonumber}' "_site/memory-analysis/valgrind-metrics.json" > "$TMP_JSON"
                mv "$TMP_JSON" "_site/memory-analysis/valgrind-metrics.json"
              else
                # Create new file
                echo "{\"peak_heap\": 0, \"peak_stack\": 0, \"app_heap\": $APP_PEAK_HEAP}" > "_site/memory-analysis/valgrind-metrics.json"
              fi
              
              echo "Updated valgrind metrics with application heap usage:"
              cat "_site/memory-analysis/valgrind-metrics.json"
            fi
          else
            echo "No memory-analysis artifact found"
          fi

          # List resulting files in the site directory for verification
          echo "Final contents of _site/memory-analysis:"
          find _site/memory-analysis -type f | sort 2>/dev/null || echo "No files found in _site/memory-analysis"

      - name: Create metrics history database
        run: |
          # Get commit hash and date
          COMMIT_HASH=$(git rev-parse --short HEAD)
          COMMIT_DATE=$(git show -s --format=%ci $COMMIT_HASH)

          echo "Current commit hash: $COMMIT_HASH"
          echo "Current commit date: $COMMIT_DATE"

          # Create metrics directory if it doesn't exist
          mkdir -p metrics-data

          # Try to fetch existing metrics from the deployed GitHub Pages site
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          GITHUB_PAGES_URL="https://${GITHUB_REPOSITORY_OWNER}.github.io/${REPO_NAME}/metrics/metrics.json"

          echo "Attempting to fetch existing metrics from $GITHUB_PAGES_URL"
          if curl -s -f -o metrics-data/metrics.json "$GITHUB_PAGES_URL"; then
            echo "Successfully fetched existing metrics"
            echo "Content of metrics file:"
            cat metrics-data/metrics.json | jq .
          else
            echo "Could not fetch existing metrics, starting with empty dataset"
            echo "[]" > metrics-data/metrics.json
          fi

          # After attempting to fetch, check if metrics.json is empty or just contains an empty array
          if [ "$(cat metrics-data/metrics.json)" = "[]" ]; then
            echo "metrics.json is empty, using initial_metrics.json as a starting point"
            if [ -f "docs/metrics/initial_metrics.json" ]; then
              cp docs/metrics/initial_metrics.json metrics-data/metrics.json
              echo "Copied initial metrics:"
              cat metrics-data/metrics.json | jq .
            fi
          fi

          # Memory size metrics
          if [ -f "artifacts/memory-analysis-reports/valgrind-metrics.json" ]; then
            echo "Using pre-generated valgrind metrics from memory-analysis-reports artifact"
            cat artifacts/memory-analysis-reports/valgrind-metrics.json
            
            # Extract heap and stack metrics from valgrind-metrics.json
            PEAK_HEAP=$(grep -o '"peak_heap": [^,]*' artifacts/memory-analysis-reports/valgrind-metrics.json | awk '{print $2}')
            PEAK_STACK=$(grep -o '"peak_stack": [^,]*' artifacts/memory-analysis-reports/valgrind-metrics.json | awk '{print $2}')
            APP_HEAP=$(grep -o '"app_heap": [^,}]*' artifacts/memory-analysis-reports/valgrind-metrics.json | awk '{print $2}')
            
            echo "Extracted peak heap: $PEAK_HEAP"
            echo "Extracted peak stack: $PEAK_STACK"
            echo "Extracted app heap: $APP_HEAP"
            
            # Ensure values are not empty
            if [ -z "$PEAK_HEAP" ]; then
              PEAK_HEAP="null"
              echo "Empty PEAK_HEAP, setting to null"
            fi
            if [ -z "$PEAK_STACK" ]; then
              PEAK_STACK="null"
              echo "Empty PEAK_STACK, setting to null"
            fi
            if [ -z "$APP_HEAP" ]; then
              APP_HEAP="null"
              echo "Empty APP_HEAP, setting to null"
            fi
          elif [ -f "artifacts/memory-analysis/valgrind-metrics.json" ]; then
            echo "Using pre-generated valgrind metrics from memory-analysis artifact"
            cat artifacts/memory-analysis/valgrind-metrics.json
            
            # Extract heap and stack metrics from valgrind-metrics.json
            PEAK_HEAP=$(grep -o '"peak_heap": [^,]*' artifacts/memory-analysis/valgrind-metrics.json | awk '{print $2}')
            PEAK_STACK=$(grep -o '"peak_stack": [^,]*' artifacts/memory-analysis/valgrind-metrics.json | awk '{print $2}')
            APP_HEAP=$(grep -o '"app_heap": [^,}]*' artifacts/memory-analysis/valgrind-metrics.json | awk '{print $2}')
            
            echo "Extracted peak heap: $PEAK_HEAP"
            echo "Extracted peak stack: $PEAK_STACK"
            echo "Extracted app heap: $APP_HEAP"
            
            # Ensure values are not empty
            if [ -z "$PEAK_HEAP" ]; then
              PEAK_HEAP="null"
              echo "Empty PEAK_HEAP, setting to null"
            fi
            if [ -z "$PEAK_STACK" ]; then
              PEAK_STACK="null"
              echo "Empty PEAK_STACK, setting to null"
            fi
            if [ -z "$APP_HEAP" ]; then
              APP_HEAP="null"
              echo "Empty APP_HEAP, setting to null"
            fi
          else
            # Fallback to parsing massif-full-report.txt if valgrind-metrics.json doesn't exist
            if [ -f "artifacts/memory-analysis-reports/massif-full-report.txt" ]; then
              PEAK_HEAP=$(grep "heap_tree=peak" artifacts/memory-analysis-reports/massif-full-report.txt -A 2 | grep "total:" | awk '{print $2}')
              PEAK_STACK=$(grep "mem_stacks_B" artifacts/memory-analysis-reports/massif-full-report.txt | awk -F= '{if($2>max) max=$2} END{print max}')
              echo "Extracted peak heap: $PEAK_HEAP, peak stack: $PEAK_STACK"
              
              # Try to extract application heap from app-heap-report.txt if available
              if [ -f "_site/memory-analysis/app-peak-heap.txt" ]; then
                APP_HEAP=$(grep "total:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | awk '{print $2}' | tr -d ',' || echo "null")
                echo "Extracted application heap: $APP_HEAP"
              else
                APP_HEAP="null"
                echo "No application heap data available"
              fi
              
              # Ensure values are not empty
              if [ -z "$PEAK_HEAP" ]; then
                PEAK_HEAP="null"
                echo "Empty PEAK_HEAP, setting to null"
              fi
              if [ -z "$PEAK_STACK" ]; then
                PEAK_STACK="null"
                echo "Empty PEAK_STACK, setting to null"
              fi
              if [ -z "$APP_HEAP" ]; then
                APP_HEAP="null"
                echo "Empty APP_HEAP, setting to null"
              fi
            elif [ -f "artifacts/memory-analysis/massif-full-report.txt" ]; then
              PEAK_HEAP=$(grep "heap_tree=peak" artifacts/memory-analysis/massif-full-report.txt -A 2 | grep "total:" | awk '{print $2}')
              PEAK_STACK=$(grep "mem_stacks_B" artifacts/memory-analysis/massif-full-report.txt | awk -F= '{if($2>max) max=$2} END{print max}')
              echo "Extracted peak heap: $PEAK_HEAP, peak stack: $PEAK_STACK"
              
              # Try to extract application heap from app-heap-report.txt if available
              if [ -f "_site/memory-analysis/app-peak-heap.txt" ]; then
                APP_HEAP=$(grep "total:" "_site/memory-analysis/app-peak-heap.txt" 2>/dev/null | awk '{print $2}' | tr -d ',' || echo "null")
                echo "Extracted application heap: $APP_HEAP"
              else
                APP_HEAP="null"
                echo "No application heap data available"
              fi
              
              # Ensure values are not empty
              if [ -z "$PEAK_HEAP" ]; then
                PEAK_HEAP="null"
                echo "Empty PEAK_HEAP, setting to null"
              fi
              if [ -z "$PEAK_STACK" ]; then
                PEAK_STACK="null"
                echo "Empty PEAK_STACK, setting to null"
              fi
              if [ -z "$APP_HEAP" ]; then
                APP_HEAP="null"
                echo "Empty APP_HEAP, setting to null"
              fi
            else
              echo "Warning: valgrind-metrics.json and massif-full-report.txt not found in either artifact"
              PEAK_HEAP="null"
              PEAK_STACK="null"
              APP_HEAP="null"
            fi
          fi

          # Executable size
          if [ -d "artifacts/memory-analysis" ]; then
            # Use the pre-generated metrics.json file from build_embedded job
            if [ -f "artifacts/memory-analysis/metrics.json" ]; then
              echo "Using pre-generated metrics from build_embedded job"
              cat artifacts/memory-analysis/metrics.json
              
              # Extract embedded metrics from metrics.json
              TEXT_SIZE=$(grep -o '"text_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              DATA_SIZE=$(grep -o '"data_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              BSS_SIZE=$(grep -o '"bss_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              TOTAL_SIZE=$(grep -o '"total_size": [^,]*' artifacts/memory-analysis/metrics.json | awk '{print $2}')
              
              echo "Extracted text size: $TEXT_SIZE"
              echo "Extracted data size: $DATA_SIZE"
              echo "Extracted BSS size: $BSS_SIZE"
              echo "Extracted total size: $TOTAL_SIZE"
              
              # For backward compatibility, still extract executable size from summary file
              EXEC_SIZE=$(grep "Executable" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
              echo "Extracted executable size: $EXEC_SIZE"
              
              # Ensure EXEC_SIZE is not empty
              if [ -z "$EXEC_SIZE" ]; then
                EXEC_SIZE="null"
                echo "Empty EXEC_SIZE, setting to null"
              fi
            else
              # Fallback to parsing size_summary.txt
              echo "Pre-generated metrics.json not found, parsing size_summary.txt"
              if [ -f "artifacts/memory-analysis/size_summary.txt" ]; then
                cat artifacts/memory-analysis/size_summary.txt
                EXEC_SIZE=$(grep "Executable" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                TEXT_SIZE=$(grep "Text" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                DATA_SIZE=$(grep "Data" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                BSS_SIZE=$(grep "BSS" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                TOTAL_SIZE=$(grep "Total" artifacts/memory-analysis/size_summary.txt 2>/dev/null | awk '{print $2}' || echo "null")
                
                echo "Extracted text size: $TEXT_SIZE"
                echo "Extracted data size: $DATA_SIZE"
                echo "Extracted BSS size: $BSS_SIZE"
                echo "Extracted total size: $TOTAL_SIZE"
                echo "Extracted executable size: $EXEC_SIZE"
                
                # Ensure values are not empty
                if [ -z "$EXEC_SIZE" ]; then
                  EXEC_SIZE="null"
                  echo "Empty EXEC_SIZE, setting to null"
                fi
                if [ -z "$TEXT_SIZE" ]; then
                  TEXT_SIZE="null"
                  echo "Empty TEXT_SIZE, setting to null"
                fi
                if [ -z "$DATA_SIZE" ]; then
                  DATA_SIZE="null"
                  echo "Empty DATA_SIZE, setting to null"
                fi
                if [ -z "$BSS_SIZE" ]; then
                  BSS_SIZE="null"
                  echo "Empty BSS_SIZE, setting to null"
                fi
                if [ -z "$TOTAL_SIZE" ]; then
                  TOTAL_SIZE="null"
                  echo "Empty TOTAL_SIZE, setting to null"
                fi
              else
                echo "Warning: size_summary.txt not found"
                EXEC_SIZE="null"
                TEXT_SIZE="null"
                DATA_SIZE="null"
                BSS_SIZE="null"
                TOTAL_SIZE="null"
              fi
            fi
          else
            echo "Warning: memory-analysis directory not found"
            EXEC_SIZE="null"
            TEXT_SIZE="null"
            DATA_SIZE="null"
            BSS_SIZE="null"
            TOTAL_SIZE="null"
          fi

          # Code coverage metrics
          if [ -f "artifacts/coverage-report/coverage_summary.txt" ]; then
            cat artifacts/coverage-report/coverage_summary.txt
            # Try different patterns to extract coverage percentage
            if grep -q "Total coverage:" artifacts/coverage-report/coverage_summary.txt; then
              TOTAL_COVERAGE=$(grep "Total coverage:" artifacts/coverage-report/coverage_summary.txt | grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' | sed 's/%//g')
            elif grep -q "Total" artifacts/coverage-report/coverage_summary.txt; then
              TOTAL_COVERAGE=$(grep "Total" artifacts/coverage-report/coverage_summary.txt | grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' | sed 's/%//g')
            else
              # Try to extract from the last line with a percentage
              TOTAL_COVERAGE=$(grep -o '[0-9]*\.[0-9]*%\|[0-9]*%' artifacts/coverage-report/coverage_summary.txt | tail -1 | sed 's/%//g')
            fi
            
            echo "Extracted coverage: $TOTAL_COVERAGE"
            # Ensure TOTAL_COVERAGE is not empty
            if [ -z "$TOTAL_COVERAGE" ]; then
              TOTAL_COVERAGE="null"
              echo "Empty TOTAL_COVERAGE, setting to null"
            fi
          else
            echo "Warning: coverage_summary.txt not found"
            TOTAL_COVERAGE="null"
          fi

          # Check for static analysis results
          if [ -f "artifacts/static-analysis-report/analysis_summary.md" ]; then
            cat artifacts/static-analysis-report/analysis_summary.md
            if grep -q "✅ Static Analysis Results" artifacts/static-analysis-report/analysis_summary.md; then
              STATIC_ANALYSIS="pass"
            else
              STATIC_ANALYSIS="fail"
            fi
            echo "Static analysis status: $STATIC_ANALYSIS"
          else
            echo "Warning: analysis_summary.md not found"
            STATIC_ANALYSIS="null"
          fi

          # Validate all metrics values to ensure they are valid for JSON
          # For each value, if it's empty, set it to "null"
          [ -z "$PEAK_HEAP" ] && PEAK_HEAP="null"
          [ -z "$PEAK_STACK" ] && PEAK_STACK="null"
          [ -z "$TEXT_SIZE" ] && TEXT_SIZE="null"
          [ -z "$DATA_SIZE" ] && DATA_SIZE="null"
          [ -z "$BSS_SIZE" ] && BSS_SIZE="null"
          [ -z "$TOTAL_SIZE" ] && TOTAL_SIZE="null"
          [ -z "$EXEC_SIZE" ] && EXEC_SIZE="null"
          [ -z "$TOTAL_COVERAGE" ] && TOTAL_COVERAGE="null"
          [ -z "$STATIC_ANALYSIS" ] && STATIC_ANALYSIS="null"

          # Create JSON using jq for proper escaping and formatting
          NEW_METRICS=$(jq -n \
              --arg commit "$COMMIT_HASH" \
              --arg date "$COMMIT_DATE" \
              --argjson heap_size "$([ "$PEAK_HEAP" = "null" ] && echo null || echo $PEAK_HEAP)" \
              --argjson stack_size "$([ "$PEAK_STACK" = "null" ] && echo null || echo $PEAK_STACK)" \
              --argjson app_heap "$([ "$APP_HEAP" = "null" ] && echo null || echo $APP_HEAP)" \
              --argjson executable_size "$([ "$EXEC_SIZE" = "null" ] && echo null || echo $EXEC_SIZE)" \
              --argjson text_size "$([ "$TEXT_SIZE" = "null" ] && echo null || echo $TEXT_SIZE)" \
              --argjson data_size "$([ "$DATA_SIZE" = "null" ] && echo null || echo $DATA_SIZE)" \
              --argjson bss_size "$([ "$BSS_SIZE" = "null" ] && echo null || echo $BSS_SIZE)" \
              --argjson total_size "$([ "$TOTAL_SIZE" = "null" ] && echo null || echo $TOTAL_SIZE)" \
              --argjson coverage "$([ "$TOTAL_COVERAGE" = "null" ] && echo null || echo $TOTAL_COVERAGE)" \
              --arg static_analysis "$STATIC_ANALYSIS" \
              '{commit: $commit, date: $date, heap_size: $heap_size, stack_size: $stack_size, 
                app_heap: $app_heap, executable_size: $executable_size, text_size: $text_size, 
                data_size: $data_size, bss_size: $bss_size, total_size: $total_size, 
                coverage: $coverage, static_analysis: $static_analysis}')

          echo "New metrics entry:"
          echo $NEW_METRICS | jq .

          # More robust check if this commit is already in the metrics file
          if jq -e ".[] | select(.commit == \"$COMMIT_HASH\")" metrics-data/metrics.json > /dev/null; then
            echo "Metrics for commit $COMMIT_HASH already exist, skipping"
          else
            echo "Adding new metrics for commit $COMMIT_HASH"
            # Add new metrics to the JSON file
            jq ". + [$NEW_METRICS]" metrics-data/metrics.json > temp.json && mv temp.json metrics-data/metrics.json
            echo "Updated metrics file:"
            cat metrics-data/metrics.json | jq .
          fi

          # Special handling for development mode or manual triggers:
          # For dev branch or manual workflow dispatch, always add a timestamp-based entry for testing
          if [[ "$GITHUB_REF" == *"dev"* || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Development mode or manual trigger detected, adding test metrics entry"
            # Create a timestamped test entry
            TIMESTAMP=$(date +%s)
            TEST_COMMIT="test-$TIMESTAMP"
            TEST_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            
            # Use the actual metric values but with a different commit hash
            TEST_METRICS=$(jq -n \
              --arg commit "$TEST_COMMIT" \
              --arg date "$TEST_DATE" \
              --argjson heap_size "$([ "$PEAK_HEAP" = "null" ] && echo null || echo $PEAK_HEAP)" \
              --argjson stack_size "$([ "$PEAK_STACK" = "null" ] && echo null || echo $PEAK_STACK)" \
              --argjson app_heap "$([ "$APP_HEAP" = "null" ] && echo null || echo $APP_HEAP)" \
              --argjson executable_size "$([ "$EXEC_SIZE" = "null" ] && echo null || echo $EXEC_SIZE)" \
              --argjson text_size "$([ "$TEXT_SIZE" = "null" ] && echo null || echo $TEXT_SIZE)" \
              --argjson data_size "$([ "$DATA_SIZE" = "null" ] && echo null || echo $DATA_SIZE)" \
              --argjson bss_size "$([ "$BSS_SIZE" = "null" ] && echo null || echo $BSS_SIZE)" \
              --argjson total_size "$([ "$TOTAL_SIZE" = "null" ] && echo null || echo $TOTAL_SIZE)" \
              --argjson coverage "$([ "$TOTAL_COVERAGE" = "null" ] && echo null || echo $TOTAL_COVERAGE)" \
              --arg static_analysis "$STATIC_ANALYSIS" \
              '{commit: $commit, date: $date, heap_size: $heap_size, stack_size: $stack_size, 
                app_heap: $app_heap, executable_size: $executable_size, text_size: $text_size, 
                data_size: $data_size, bss_size: $bss_size, total_size: $total_size, 
                coverage: $coverage, static_analysis: $static_analysis}')
            
            echo "Adding test metrics entry for development:"
            echo $TEST_METRICS | jq .
            
            # Add the test metrics to the JSON file
            jq ". + [$TEST_METRICS]" metrics-data/metrics.json > temp.json && mv temp.json metrics-data/metrics.json
          fi

          # Copy metrics data to site
          cp metrics-data/metrics.json _site/metrics/

      - name: Create visualization pages
        run: |
          # Create index.html
          cat > _site/index.html << 'EOL'
          <!DOCTYPE html>
          <html lang="en" data-bs-theme="dark">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Colibri Project Metrics</title>
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
              body {
                background-color: #121212;
                color: #e0e0e0;
              }
              .card {
                background-color: #1e1e1e;
                border-color: #333;
              }
              .card-header {
                background-color: #252525;
                border-color: #333;
              }
              .list-group-item {
                background-color: #1e1e1e;
                border-color: #333;
                color: #e0e0e0;
              }
              .list-group-item a {
                color: #8ab4f8;
              }
              .btn-outline-primary {
                color: #8ab4f8;
                border-color: #8ab4f8;
              }
              .btn-outline-primary:hover {
                background-color: #8ab4f8;
                color: #121212;
              }
              .theme-toggle {
                position: absolute;
                top: 10px;
                right: 20px;
                cursor: pointer;
                font-size: 1.2rem;
              }
            </style>
          </head>
          <body>
            <div class="container mt-5">
              <div class="theme-toggle" id="themeToggle">🌞</div>
              <h1 class="mb-4">Colibri Project Metrics</h1>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Memory Usage</h5>
                    </div>
                    <div class="card-body">
                      <canvas id="memoryChart"></canvas>
                      <div class="mt-3 small text-muted">
                        <p><strong>Max Heap</strong> shows total memory allocation peak during program execution.</p>
                        <p><strong>Max Stack</strong> shows maximum stack usage during program execution.</p>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Code Coverage </h5>
                    </div>
                    <div class="card-body">
                      <canvas id="coverageChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Embedded Metrics </h5>
                    </div>
                    <div class="card-body">
                      <canvas id="embeddedMetricsChart"></canvas>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Latest Static Analysis</h5>
                    </div>
                    <div class="card-body">
                      <div id="staticAnalysisStatus" class="alert" role="alert">
                        Loading static analysis status...
                      </div>
                      <div class="mt-3">
                        <a href="./static-analysis/index.html" class="btn btn-outline-primary" id="viewStaticAnalysisBtn">View Static Analysis Report</a>
                      </div>
                      <div class="mt-3">
                        <canvas id="staticAnalysisChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="row mb-4">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header">
                      <h5>Latest Reports</h5>
                    </div>
                    <div class="card-body">
                      <ul class="list-group">
                        <li class="list-group-item">
                          <a href="./coverage/index.html">Coverage Report</a>
                        </li>
                        <li class="list-group-item">
                          <a href="./memory-analysis/massif-full-report.txt">Memory Analysis Report</a>
                        </li>
                        <li class="list-group-item">
                          <a href="./static-analysis/analysis_summary.md">Static Analysis Summary</a>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- New Metrics Data Table Section -->
              <div class="row mb-4">
                <div class="col-12">
                  <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                      <h5>Metrics Data Table</h5>
                      <div>
                        <button class="btn btn-sm btn-outline-primary" id="toggleTableBtn">Show/Hide Full Table</button>
                        <button class="btn btn-sm btn-outline-primary ms-2" id="exportCSVBtn">Export CSV</button>
                      </div>
                    </div>
                    <div class="card-body">
                      <div class="table-responsive" id="metricsTableContainer" style="display: none;">
                        <table class="table table-striped table-bordered" id="metricsTable">
                          <thead>
                            <tr>
                              <th>Date</th>
                              <th>Commit</th>
                              <th>Text Size (KB)</th>
                              <th>Data Size (KB)</th>
                              <th>BSS Size (KB)</th>
                              <th>Total Size (KB)</th>
                              <th>Peak Heap (KB)</th>
                              <th>Peak Stack (KB)</th>
                              <th>Coverage (%)</th>
                              <th>Static Analysis</th>
                            </tr>
                          </thead>
                          <tbody id="metricsTableBody">
                            <!-- Table content will be populated by JavaScript -->
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <script>
              // Theme toggle functionality
              const themeToggle = document.getElementById('themeToggle');
              themeToggle.addEventListener('click', () => {
                const htmlElement = document.documentElement;
                if (htmlElement.getAttribute('data-bs-theme') === 'dark') {
                  htmlElement.setAttribute('data-bs-theme', 'light');
                  document.body.style.backgroundColor = '#ffffff';
                  document.body.style.color = '#212529';
                  themeToggle.textContent = '🌙';
                  // Update all cards and list items
                  document.querySelectorAll('.card, .list-group-item').forEach(el => {
                    el.style.backgroundColor = '';
                    el.style.borderColor = '';
                  });
                  document.querySelectorAll('.card-header').forEach(el => {
                    el.style.backgroundColor = '';
                    el.style.borderColor = '';
                  });
                  document.querySelectorAll('.list-group-item').forEach(el => {
                    el.style.color = '';
                  });
                  document.querySelectorAll('.list-group-item a').forEach(el => {
                    el.style.color = '';
                  });
                  document.querySelectorAll('.btn-outline-primary').forEach(el => {
                    el.style.color = '';
                    el.style.borderColor = '';
                  });
                } else {
                  htmlElement.setAttribute('data-bs-theme', 'dark');
                  document.body.style.backgroundColor = '#121212';
                  document.body.style.color = '#e0e0e0';
                  themeToggle.textContent = '🌞';
                  // Update all cards and list items
                  document.querySelectorAll('.card, .list-group-item').forEach(el => {
                    el.style.backgroundColor = '#1e1e1e';
                    el.style.borderColor = '#333';
                  });
                  document.querySelectorAll('.card-header').forEach(el => {
                    el.style.backgroundColor = '#252525';
                    el.style.borderColor = '#333';
                  });
                  document.querySelectorAll('.list-group-item').forEach(el => {
                    el.style.color = '#e0e0e0';
                  });
                  document.querySelectorAll('.list-group-item a').forEach(el => {
                    el.style.color = '#8ab4f8';
                  });
                  document.querySelectorAll('.btn-outline-primary').forEach(el => {
                    el.style.color = '#8ab4f8';
                    el.style.borderColor = '#8ab4f8';
                  });
                }
                // Re-render charts with appropriate colors
                updateChartsForTheme();
              });
              
              // Function to update chart colors based on theme
              function updateChartsForTheme() {
                // This would be called when theme changes and after charts are initialized
                // Not implemented fully here as it would require storing chart instances
              }
              
              // Define chart colors for dark mode
              const isDarkMode = document.documentElement.getAttribute('data-bs-theme') === 'dark';
              const colors = {
                text: isDarkMode ? 'rgba(255, 159, 64, 0.8)' : 'rgba(255, 159, 64, 1)',
                data: isDarkMode ? 'rgba(75, 192, 192, 0.8)' : 'rgba(75, 192, 192, 1)',
                bss: isDarkMode ? 'rgba(153, 102, 255, 0.8)' : 'rgba(153, 102, 255, 1)',
                total: isDarkMode ? 'rgba(54, 162, 235, 0.8)' : 'rgba(54, 162, 235, 1)',
                heap: isDarkMode ? 'rgba(75, 192, 192, 0.8)' : 'rgba(75, 192, 192, 1)',
                stack: isDarkMode ? 'rgba(153, 102, 255, 0.8)' : 'rgba(153, 102, 255, 1)',
                appHeap: isDarkMode ? 'rgba(255, 99, 132, 0.8)' : 'rgba(255, 99, 132, 1)',
                coverage: isDarkMode ? 'rgba(255, 99, 132, 0.8)' : 'rgba(255, 99, 132, 1)',
                staticAnalysis: isDarkMode ? 'rgba(54, 162, 235, 0.8)' : 'rgba(54, 162, 235, 1)'
              };
              
              // Extract repository information from the URL for commit links
              let repoOwner = '';
              let repoName = '';
              
              // Try to extract from the current page URL
              const currentUrl = window.location.href;
              const githubIoMatch = currentUrl.match(/https:\/\/([^.]+)\.github\.io\/([^\/]+)/);
              if (githubIoMatch) {
                repoOwner = githubIoMatch[1];
                repoName = githubIoMatch[2];
              }
              
              // Function to format a commit hash as a GitHub link
              function formatCommitLink(hash) {
                if (repoOwner && repoName && !hash.startsWith('test-')) {
                  return `<a href="https://github.com/${repoOwner}/${repoName}/commit/${hash}" target="_blank" title="View commit on GitHub">${hash}</a>`;
                }
                return hash;
              }
              
              // Function to get commit info for tooltips
              function getCommitInfo(commit) {
                if (repoOwner && repoName && !commit.startsWith('test-')) {
                  return `Commit: ${commit}\nClick to view on GitHub`;
                }
                return `Commit: ${commit}`;
              }
              
              // Add event listener for chart clicks to navigate to commit
              function addChartClickHandler(chart, data) {
                chart.canvas.onclick = function(evt) {
                  const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                  
                  if (points.length) {
                    const firstPoint = points[0];
                    const dataIndex = firstPoint.index;
                    const commit = data[dataIndex].commit;
                    
                    if (repoOwner && repoName && !commit.startsWith('test-')) {
                      window.open(`https://github.com/${repoOwner}/${repoName}/commit/${commit}`, '_blank');
                    }
                  }
                };
              }
              
              // Function to format metrics for display
              function formatMetric(value) {
                if (value === null) return 'N/A';
                return typeof value === 'number' ? value.toFixed(2) : value;
              }
              
              // Function to populate the metrics table
              function populateMetricsTable(data) {
                const tableBody = document.getElementById('metricsTableBody');
                tableBody.innerHTML = '';
                
                // Sort data by date (newest first)
                const sortedData = [...data]
                  .filter(entry => !entry.commit.startsWith('test-')) // Filter out test entries
                  .sort((a, b) => new Date(b.date) - new Date(a.date));
                
                sortedData.forEach(entry => {
                  const row = document.createElement('tr');
                  
                  // Format date
                  const date = new Date(entry.date);
                  const formattedDate = date.toLocaleString();
                  
                  // Calculate KB values
                  const textSize = entry.text_size !== null ? (typeof entry.text_size === 'string' ? parseFloat(entry.text_size) : entry.text_size) : null;
                  const dataSize = entry.data_size !== null ? (typeof entry.data_size === 'string' ? parseFloat(entry.data_size) : entry.data_size) : null;
                  const bssSize = entry.bss_size !== null ? (typeof entry.bss_size === 'string' ? parseFloat(entry.bss_size) : entry.bss_size) : null;
                  const totalSize = entry.total_size !== null ? (typeof entry.total_size === 'string' ? parseFloat(entry.total_size) : entry.total_size) : null;
                  const heapSize = entry.heap_size !== null ? (typeof entry.heap_size === 'string' ? parseFloat(entry.heap_size) / 1024 : entry.heap_size / 1024) : null;
                  const stackSize = entry.stack_size !== null ? (typeof entry.stack_size === 'string' ? parseFloat(entry.stack_size) / 1024 : entry.stack_size / 1024) : null;
                  
                  // Create row content
                  row.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${formatCommitLink(entry.commit)}</td>
                    <td>${formatMetric(textSize)}</td>
                    <td>${formatMetric(dataSize)}</td>
                    <td>${formatMetric(bssSize)}</td>
                    <td>${formatMetric(totalSize)}</td>
                    <td>${formatMetric(heapSize)}</td>
                    <td>${formatMetric(stackSize)}</td>
                    <td>${entry.coverage === null ? 'N/A' : entry.coverage + '%'}</td>
                    <td>${entry.static_analysis === 'pass' ? '✅ Pass' : entry.static_analysis === 'fail' ? '⚠️ Fail' : 'N/A'}</td>
                  `;
                  
                  tableBody.appendChild(row);
                });
              }
              
              // Function to export table data to CSV
              function exportTableToCSV() {
                const table = document.getElementById('metricsTable');
                let csv = [];
                
                // Get header row
                const headerRow = [];
                const headers = table.querySelectorAll('thead th');
                headers.forEach(header => {
                  headerRow.push('"' + header.textContent + '"');
                });
                csv.push(headerRow.join(','));
                
                // Get data rows
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                  const rowData = [];
                  const cells = row.querySelectorAll('td');
                  cells.forEach((cell, index) => {
                    // For commit column, get text content instead of HTML with link
                    if (index === 1) {
                      // Extract just the commit hash from the link
                      const link = cell.querySelector('a');
                      rowData.push('"' + (link ? link.textContent : cell.textContent) + '"');
                    } else {
                      rowData.push('"' + cell.textContent + '"');
                    }
                  });
                  csv.push(rowData.join(','));
                });
                
                // Download CSV file
                const csvContent = "data:text/csv;charset=utf-8," + csv.join('\n');
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "metrics_data.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
              }
              
              // Fetch the metrics data
              fetch('./metrics/metrics.json')
                .then(response => response.json())
                .then(data => {
                  // Filter out test entries
                  data = data.filter(entry => !entry.commit.startsWith('test-'));
                  
                  // Sort data by date
                  data.sort((a, b) => new Date(a.date) - new Date(b.date));
                  
                  // Format dates for display
                  const dates = data.map(entry => {
                    const date = new Date(entry.date);
                    return date.toLocaleDateString();
                  });
                  
                  // Extract metrics
                  const heapSizes = data.map(entry => entry.heap_size === null ? null : 
                    typeof entry.heap_size === 'string' ? parseFloat(entry.heap_size) / 1024 : entry.heap_size / 1024); // Convert to KB
                  const stackSizes = data.map(entry => entry.stack_size === null ? null : 
                    typeof entry.stack_size === 'string' ? parseFloat(entry.stack_size) / 1024 : entry.stack_size / 1024); // Convert to KB
                  const coverageValues = data.map(entry => entry.coverage);
                  
                  // Extract embedded metrics
                  const textSizes = data.map(entry => entry.text_size === null ? null : 
                    typeof entry.text_size === 'string' ? parseFloat(entry.text_size) : entry.text_size);
                  const dataSizes = data.map(entry => entry.data_size === null ? null : 
                    typeof entry.data_size === 'string' ? parseFloat(entry.data_size) : entry.data_size);
                  const bssSizes = data.map(entry => entry.bss_size === null ? null : 
                    typeof entry.bss_size === 'string' ? parseFloat(entry.bss_size) : entry.bss_size);
                  const totalSizes = data.map(entry => entry.total_size === null ? null : 
                    typeof entry.total_size === 'string' ? parseFloat(entry.total_size) : entry.total_size);
                  
                  // Create memory chart
                  const memoryCtx = document.getElementById('memoryChart').getContext('2d');
                  const memoryChart = new Chart(memoryCtx, {
                    type: 'line',
                    data: {
                      labels: dates,
                      datasets: [
                        {
                          label: 'Peak Heap (KB)',
                          data: heapSizes,
                          borderColor: colors.heap,
                          backgroundColor: isDarkMode ? 'rgba(75, 192, 192, 0.1)' : 'rgba(75, 192, 192, 0.2)',
                          tension: 0.1,
                          order: 2
                        },
                        {
                          label: 'Peak Stack (KB)',
                          data: stackSizes,
                          borderColor: colors.stack,
                          backgroundColor: isDarkMode ? 'rgba(153, 102, 255, 0.1)' : 'rgba(153, 102, 255, 0.2)',
                          tension: 0.1,
                          order: 3
                        }
                      ]
                    },
                    options: {
                      scales: {
                        y: {
                          beginAtZero: true,
                          title: {
                            display: true,
                            text: 'Size (KB)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        },
                        tooltip: {
                          callbacks: {
                            afterTitle: function(tooltipItems) {
                              const index = tooltipItems[0].dataIndex;
                              return getCommitInfo(data[index].commit);
                            }
                          }
                        }
                      }
                    }
                  });
                  
                  // Add click handler to memory chart
                  addChartClickHandler(memoryChart, data);
                  
                  // Create coverage chart
                  const coverageCtx = document.getElementById('coverageChart').getContext('2d');
                  const coverageChart = new Chart(coverageCtx, {
                    type: 'line',
                    data: {
                      labels: dates,
                      datasets: [{
                        label: 'Code Coverage (%)',
                        data: coverageValues,
                        borderColor: colors.coverage,
                        backgroundColor: isDarkMode ? 'rgba(255, 99, 132, 0.1)' : 'rgba(255, 99, 132, 0.2)',
                        tension: 0.1
                      }]
                    },
                    options: {
                      scales: {
                        y: {
                          beginAtZero: true,
                          max: 100,
                          title: {
                            display: true,
                            text: 'Coverage (%)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        },
                        tooltip: {
                          callbacks: {
                            afterTitle: function(tooltipItems) {
                              const index = tooltipItems[0].dataIndex;
                              return getCommitInfo(data[index].commit);
                            }
                          }
                        }
                      }
                    }
                  });
                  
                  // Add click handler to coverage chart
                  addChartClickHandler(coverageChart, data);
                  
                  // Create embedded metrics chart (stacked)
                  const embeddedCtx = document.getElementById('embeddedMetricsChart').getContext('2d');
                  const embeddedChart = new Chart(embeddedCtx, {
                    type: 'bar', // Changed to bar for stacking
                    data: {
                      labels: dates,
                      datasets: [
                        {
                          label: 'Text Size (KB)',
                          data: textSizes,
                          backgroundColor: colors.text,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'Data Size (KB)',
                          data: dataSizes,
                          backgroundColor: colors.data,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'BSS Size (KB)',
                          data: bssSizes,
                          backgroundColor: colors.bss,
                          stack: 'embedded-stack'
                        },
                        {
                          label: 'Total Size (KB)',
                          data: totalSizes,
                          type: 'line',
                          borderColor: colors.total,
                          backgroundColor: 'transparent',
                          borderWidth: 2,
                          tension: 0.1,
                          pointRadius: 3,
                          pointBackgroundColor: colors.total
                        }
                      ]
                    },
                    options: {
                      scales: {
                        y: {
                          stacked: true, // Enable stacking
                          beginAtZero: true,
                          title: {
                            display: true,
                            text: 'Size (KB)',
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        },
                        x: {
                          stacked: true, // Enable stacking
                          ticks: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          },
                          grid: {
                            color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          labels: {
                            color: isDarkMode ? '#e0e0e0' : '#666'
                          }
                        },
                        tooltip: {
                          callbacks: {
                            afterTitle: function(tooltipItems) {
                              const index = tooltipItems[0].dataIndex;
                              return getCommitInfo(data[index].commit);
                            },
                            footer: function(tooltipItems) {
                              // Add the sum to the tooltip
                              let sum = 0;
                              tooltipItems.forEach(function(tooltipItem) {
                                // Exclude the Total Size dataset which is index 3
                                if (tooltipItem.datasetIndex < 3) {
                                  sum += tooltipItem.parsed.y;
                                }
                              });
                              return 'Sum: ' + sum.toFixed(2) + ' KB';
                            }
                          }
                        }
                      }
                    }
                  });
                  
                  // Add click handler to embedded metrics chart
                  addChartClickHandler(embeddedChart, data);
                  
                  // Process static analysis results for chart
                  const staticResults = data.map(entry => {
                    if (!entry.static_analysis || entry.static_analysis === "null") {
                      return null;
                    }
                    return entry.static_analysis === "pass" ? 1 : 0;
                  });
                  
                  // Create static analysis chart (only if we have data)
                  if (staticResults.some(result => result !== null)) {
                    const staticAnalysisCtx = document.getElementById('staticAnalysisChart').getContext('2d');
                    const staticAnalysisChart = new Chart(staticAnalysisCtx, {
                      type: 'line',
                      data: {
                        labels: dates,
                        datasets: [{
                          label: 'Static Analysis Status',
                          data: staticResults,
                          borderColor: colors.staticAnalysis,
                          backgroundColor: isDarkMode ? 'rgba(54, 162, 235, 0.1)' : 'rgba(54, 162, 235, 0.2)',
                          tension: 0.1,
                          stepped: true
                        }]
                      },
                      options: {
                        scales: {
                          y: {
                            min: 0,
                            max: 1,
                            ticks: {
                              stepSize: 1,
                              callback: function(value) {
                                return value === 1 ? 'Pass' : 'Fail';
                              },
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            title: {
                              display: true,
                              text: 'Status',
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            grid: {
                              color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                          },
                          x: {
                            ticks: {
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            },
                            grid: {
                              color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                          }
                        },
                        plugins: {
                          legend: {
                            labels: {
                              color: isDarkMode ? '#e0e0e0' : '#666'
                            }
                          },
                          tooltip: {
                            callbacks: {
                              afterTitle: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return getCommitInfo(data[index].commit);
                              }
                            }
                          }
                        }
                      }
                    });
                    
                    // Add click handler to static analysis chart
                    addChartClickHandler(staticAnalysisChart, data);
                  }
                  
                  // Update latest status widget based on most recent data
                  const latestData = [...data].sort((a, b) => new Date(b.date) - new Date(a.date))[0];
                  const statusElement = document.getElementById('staticAnalysisStatus');
                  
                  if (latestData && latestData.static_analysis) {
                    if (latestData.static_analysis === "pass") {
                      statusElement.className = 'alert alert-success';
                      statusElement.textContent = '✅ Latest static analysis passed with no issues';
                    } else if (latestData.static_analysis === "fail") {
                      statusElement.className = 'alert alert-warning';
                      statusElement.textContent = '⚠️ Latest static analysis found issues';
                    } else {
                      statusElement.className = 'alert alert-secondary';
                      statusElement.textContent = 'ℹ️ Static analysis status unknown';
                    }
                  }
                  
                  // Populate the metrics table
                  populateMetricsTable(data);
                  
                  // Add event listeners for table controls
                  document.getElementById('toggleTableBtn').addEventListener('click', function() {
                    const tableContainer = document.getElementById('metricsTableContainer');
                    tableContainer.style.display = tableContainer.style.display === 'none' ? 'block' : 'none';
                    this.textContent = tableContainer.style.display === 'none' ? 'Show Full Table' : 'Hide Full Table';
                  });
                  
                  document.getElementById('exportCSVBtn').addEventListener('click', exportTableToCSV);
                })
                .catch(error => console.error('Error loading metrics:', error));
                
              // Fetch static analysis status
              fetch('./static-analysis/status.json')
                .then(response => response.json())
                .then(data => {
                  const statusElement = document.getElementById('staticAnalysisStatus');
                  const reportBtn = document.getElementById('viewStaticAnalysisBtn');
                  
                  if (data.status === 'success') {
                    statusElement.className = 'alert alert-success';
                    statusElement.textContent = '✅ No static analysis issues found';
                  } else if (data.status === 'warning') {
                    statusElement.className = 'alert alert-warning';
                    statusElement.textContent = '⚠️ Static analysis issues found';
                  } else {
                    statusElement.className = 'alert alert-secondary';
                    statusElement.textContent = 'ℹ️ ' + data.message;
                  }
                  
                  // Update report button href based on available files
                  fetch('./static-analysis/index.html')
                    .then(() => {
                      // HTML report exists, keep default link
                    })
                    .catch(() => {
                      // HTML report doesn't exist, update button to analysis summary
                      reportBtn.href = './static-analysis/analysis_summary.md';
                    });
                })
                .catch(error => {
                  // If static analysis status fetch fails, metrics will still provide the info
                  console.log('Static analysis status file not available, using metrics data instead');
                });
            </script>
          </body>
          </html>
          EOL

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

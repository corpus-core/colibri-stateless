name: Release Creation

on:
  workflow_run:
    workflows: ["CMake on multiple platforms", "Bindings Pipeline"]
    types:
      - completed
    branches: [main, dev]

permissions:
  contents: write
  checks: read
  actions: read

jobs:
  check-workflows-and-tag:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check_release.outputs.should_release }}
      tag_name: ${{ steps.check_tag.outputs.tag_name }}
    steps:
      - name: Debug Workflow Info
        run: |
          echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
          echo "Workflow name: ${{ github.event.workflow_run.name }}"
          echo "Head SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "Head branch: ${{ github.event.workflow_run.head_branch }}"
          echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"

      # Check if this is a tag commit and which workflows have run
      - name: Check workflows completion and tag
        id: check_release
        run: |
          # Only proceed if the triggering workflow succeeded
          if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
            echo "Triggering workflow did not succeed"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get head SHA for this run
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          echo "Commit SHA: $HEAD_SHA"

          # Check if both workflows have completed successfully for this SHA
          echo "Checking CMake workflow..."
          CMAKE_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cmake.yml/runs?status=completed&head_sha=$HEAD_SHA")

          CMAKE_SUCCESS=$(echo "$CMAKE_RUNS" | jq '.workflow_runs | map(select(.conclusion == "success")) | length')
          echo "CMake successful runs: $CMAKE_SUCCESS"

          echo "Checking Bindings workflow..."
          BINDINGS_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/bindings.yml/runs?status=completed&head_sha=$HEAD_SHA")

          BINDINGS_SUCCESS=$(echo "$BINDINGS_RUNS" | jq '.workflow_runs | map(select(.conclusion == "success")) | length')
          echo "Bindings successful runs: $BINDINGS_SUCCESS"

          echo "Checking Build Installers workflow..."
          INSTALLERS_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-installers.yml/runs?status=completed&head_sha=$HEAD_SHA")

          INSTALLERS_SUCCESS=$(echo "$INSTALLERS_RUNS" | jq '.workflow_runs | map(select(.conclusion == "success")) | length')
          echo "Build Installers successful runs: $INSTALLERS_SUCCESS"

          # Check if this commit has any tags
          echo "Checking for tags..."
          TAGS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/git/refs/tags")

          # Find tags that point to this commit
          MATCHING_TAGS=$(echo "$TAGS" | jq -r ".[] | select(.object.sha == \"$HEAD_SHA\") | .ref" | sed 's|refs/tags/||')
          echo "Matching tags: $MATCHING_TAGS"

          # Make decision
          if [[ "$CMAKE_SUCCESS" -gt 0 && "$BINDINGS_SUCCESS" -gt 0 && "$INSTALLERS_SUCCESS" -gt 0 && -n "$MATCHING_TAGS" ]]; then
            # All workflows succeeded and there's at least one tag - proceed with release
            echo "All workflows succeeded and tag found - should create release"
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            # Conditions not met - don't proceed
            echo "Not all conditions met for release:"
            echo "- CMake success: $CMAKE_SUCCESS (need > 0)"
            echo "- Bindings success: $BINDINGS_SUCCESS (need > 0)"
            echo "- Build Installers success: $INSTALLERS_SUCCESS (need > 0)"
            echo "- Tags found: $MATCHING_TAGS"
            echo "should_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Find appropriate tag
        id: check_tag
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"

          # Fetch all tags that point to this commit
          TAGS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/git/refs/tags")

          # Find tags that point to this commit
          MATCHING_TAGS=$(echo "$TAGS" | jq -r ".[] | select(.object.sha == \"$HEAD_SHA\") | .ref" | sed 's|refs/tags/||')

          # Try to find a version tag first (starts with v)
          for TAG in $MATCHING_TAGS; do
            if [[ "$TAG" == v* ]]; then
              echo "Using version tag: $TAG"
              echo "tag_name=$TAG" >> $GITHUB_OUTPUT
              exit 0
            fi
          done

          # If no version tag found, use the first tag
          TAG=$(echo "$MATCHING_TAGS" | head -n 1)
          echo "No version tag found, using first tag: $TAG"
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT

  create-release:
    needs: check-workflows-and-tag
    if: needs.check-workflows-and-tag.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Debug Info
        run: |
          echo "Creating release for tag: ${{ needs.check-workflows-and-tag.outputs.tag_name }}"

      # List available artifacts first for diagnostics
      - name: List Available CMake Artifacts
        run: |
          echo "Trigger commit SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "Current workflow SHA: ${{ github.sha }}"
          echo "Listing available artifacts for CMake workflow..."
          # Get the workflow ID for cmake.yml
          WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cmake.yml" | \
            jq -r '.id')
          echo "CMake workflow ID: $WORKFLOW_ID"

          # List all runs for this commit
          RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/$WORKFLOW_ID/runs?head_sha=${{ github.event.workflow_run.head_sha }}")

          RUN_IDS=$(echo "$RUNS" | jq '.workflow_runs[].id')
          echo "Found runs with IDs: $RUN_IDS"

          # Check artifacts for each run
          for RUN_ID in $RUN_IDS; do
            echo "Checking artifacts for run $RUN_ID..."
            ARTIFACTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts")
            
            ARTIFACT_COUNT=$(echo "$ARTIFACTS" | jq '.total_count')
            ARTIFACT_NAMES=$(echo "$ARTIFACTS" | jq -r '.artifacts[].name')
            
            echo "Found $ARTIFACT_COUNT artifacts: $ARTIFACT_NAMES"
          done

      # Download all release artifacts using a loop for better maintainability
      - name: Download All Release Artifacts
        run: |
          echo "üì¶ Starting artifact downloads..."
          echo ""
          
          # First, download all CMake matrix artifacts (multiple artifacts with pattern)
          echo "‚¨áÔ∏è  Downloading CMake matrix artifacts (all cmake-release-*)"
          
          WORKFLOW_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cmake.yml/runs?head_sha=${{ github.event.workflow_run.head_sha }}&status=completed")
          
          RUN_ID=$(echo "$WORKFLOW_RUNS" | jq -r '.workflow_runs | map(select(.conclusion == "success")) | .[0].id')
          
          if [ "$RUN_ID" != "null" ] && [ -n "$RUN_ID" ]; then
            ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts")
            
            # Find all cmake-release-* artifacts
            CMAKE_ARTIFACTS=$(echo "$ARTIFACTS_JSON" | jq -r '.artifacts[] | select(.name | startswith("cmake-release-")) | .id')
            
            mkdir -p "artifacts/cmake"
            CMAKE_COUNT=0
            
            for ARTIFACT_ID in $CMAKE_ARTIFACTS; do
              ARTIFACT_NAME=$(echo "$ARTIFACTS_JSON" | jq -r ".artifacts[] | select(.id == $ARTIFACT_ID) | .name")
              echo "   - Downloading: $ARTIFACT_NAME"
              
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" \
                -o "artifacts/cmake/${ARTIFACT_NAME}.zip"
              
              if [ -f "artifacts/cmake/${ARTIFACT_NAME}.zip" ]; then
                cd "artifacts/cmake"
                unzip -q "${ARTIFACT_NAME}.zip" -d "$ARTIFACT_NAME"
                rm "${ARTIFACT_NAME}.zip"
                cd ../..
                CMAKE_COUNT=$((CMAKE_COUNT+1))
              fi
            done
            
            if [ "$CMAKE_COUNT" -gt 0 ]; then
              echo "   ‚úÖ Downloaded $CMAKE_COUNT CMake artifacts successfully"
            else
              echo "   ‚ö†Ô∏è  No CMake artifacts found"
            fi
          else
            echo "   ‚ö†Ô∏è  WARNING: No successful CMake workflow run found"
            mkdir -p "artifacts/cmake"
          fi
          
          echo ""
          
          # Define single-name artifacts to download: "workflow|artifact_name|target_path|verify_pattern"
          ARTIFACTS=(
            "bindings.yml|swift_package|swift_package|*"
            "bindings.yml|c4-wasm|wasm|*.zip"
            "bindings.yml|colibri-aar|aar|*.aar"
            "bindings.yml|colibri-jar|jar|*.jar"
            "bindings.yml|python-universal-distribution|python|*.whl"
            "build-installers.yml|debian-package|debian-package|*.deb"
            "build-installers.yml|rpm-package|rpm-package|*.rpm"
            "build-installers.yml|macos-package|macos-package|*.pkg"
            "build-installers.yml|windows-installer|windows-installer|*.msi"
          )
          
          # Download single-name artifacts
          for artifact_def in "${ARTIFACTS[@]}"; do
            IFS='|' read -r workflow_file artifact_name target_path verify_pattern <<< "$artifact_def"
            
            echo "‚¨áÔ∏è  Downloading: $artifact_name from $workflow_file"
            
            # Get workflow runs for this commit
            WORKFLOW_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/$workflow_file/runs?head_sha=${{ github.event.workflow_run.head_sha }}&status=completed")
            
            # Find successful run ID
            RUN_ID=$(echo "$WORKFLOW_RUNS" | jq -r '.workflow_runs | map(select(.conclusion == "success")) | .[0].id')
            
            if [ "$RUN_ID" = "null" ] || [ -z "$RUN_ID" ]; then
              echo "   ‚ö†Ô∏è  WARNING: No successful run found for $workflow_file"
              mkdir -p "artifacts/$target_path"
              continue
            fi
            
            # Get artifact ID
            ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts")
            
            ARTIFACT_ID=$(echo "$ARTIFACTS_JSON" | jq -r ".artifacts | map(select(.name == \"$artifact_name\")) | .[0].id")
            
            if [ "$ARTIFACT_ID" = "null" ] || [ -z "$ARTIFACT_ID" ]; then
              echo "   ‚ö†Ô∏è  WARNING: Artifact $artifact_name not found in run $RUN_ID"
              mkdir -p "artifacts/$target_path"
              continue
            fi
            
            # Download artifact
            mkdir -p "artifacts/$target_path"
            curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" \
              -o "artifacts/$target_path/artifact.zip"
            
            # Extract artifact
            if [ -f "artifacts/$target_path/artifact.zip" ]; then
              cd "artifacts/$target_path"
              unzip -q artifact.zip
              rm artifact.zip
              cd ../..
              
              # Verify
              if [ "$verify_pattern" != "*" ]; then
                FILE_COUNT=$(find "artifacts/$target_path" -name "$verify_pattern" | wc -l)
              else
                FILE_COUNT=$(find "artifacts/$target_path" -type f | wc -l)
              fi
              
              if [ "$FILE_COUNT" -gt 0 ]; then
                echo "   ‚úÖ Downloaded successfully: $FILE_COUNT file(s)"
              else
                echo "   ‚ö†Ô∏è  Downloaded but no files matching pattern found"
              fi
            else
              echo "   ‚ùå Download failed"
            fi
            
            echo ""
          done
          
          echo "üì¶ All artifact downloads complete"

      - name: Prepare Release Files
        run: |
          cd artifacts

          # Create release files directory
          mkdir -p release_files

          # Check if we have any files to include in the release
          TOTAL_FILES=0

          # Zip Swift package if not already zipped
          if [ -d "swift_package" ] && [ "$(ls -A swift_package)" ]; then
            cd swift_package
            zip -r ../colibri-swift-package.zip ./*
            cd ..
            if [ -f "colibri-swift-package.zip" ]; then
              mv colibri-swift-package.zip release_files/
              echo "Added Swift package to release"
              TOTAL_FILES=$((TOTAL_FILES+1))
            fi
          else
            echo "Warning: Swift package directory is empty or does not exist"
          fi

          # Move WASM files
          if [ -d "wasm" ] && [ "$(ls -A wasm)" ]; then
            find wasm -name "*.zip" -exec cp {} release_files/ \;
            NUM_FILES=$(find release_files -name "*wasm*.zip" | wc -l)
            if [ "$NUM_FILES" -gt 0 ]; then
              echo "Added $NUM_FILES WASM files to release"
              TOTAL_FILES=$((TOTAL_FILES+NUM_FILES))
            else
              echo "No WASM zip files found to add to release"
            fi
          else
            echo "Warning: WASM directory is empty or does not exist"
          fi

          # Move AAR files
          if [ -d "aar" ] && [ "$(ls -A aar)" ]; then
            find aar -name "*.aar" -exec cp {} release_files/ \;
            NUM_FILES=$(find release_files -name "*.aar" | wc -l)
            if [ "$NUM_FILES" -gt 0 ]; then
              echo "Added $NUM_FILES AAR files to release"
              TOTAL_FILES=$((TOTAL_FILES+NUM_FILES))
            else
              echo "No AAR files found to add to release"
            fi
          else
            echo "Warning: AAR directory is empty or does not exist"
          fi

          # Move JAR files
          if [ -d "jar" ] && [ "$(ls -A jar)" ]; then
            find jar -name "*.jar" -exec cp {} release_files/ \;
            NUM_FILES=$(find release_files -name "*.jar" | wc -l)
            if [ "$NUM_FILES" -gt 0 ]; then
              echo "Added $NUM_FILES JAR files to release"
              TOTAL_FILES=$((TOTAL_FILES+NUM_FILES))
            else
              echo "No JAR files found to add to release"
            fi
          else
            echo "Warning: JAR directory is empty or does not exist"
          fi

          # Move Python wheel files
          if [ -d "python" ] && [ "$(find python -name "*.whl" | wc -l)" -gt 0 ]; then
            # Create a Python distribution zip
            cd python
            zip -r ../colibri-python-wheels.zip ./*
            cd ..
            if [ -f "colibri-python-wheels.zip" ]; then
              mv colibri-python-wheels.zip release_files/
              echo "Added Python wheels package to release"
              TOTAL_FILES=$((TOTAL_FILES+1))
            fi
            
            # Also copy individual wheel files
            find python -name "*.whl" -exec cp {} release_files/ \;
            NUM_FILES=$(find release_files -name "*.whl" | wc -l)
            if [ "$NUM_FILES" -gt 0 ]; then
              echo "Added $NUM_FILES individual Python wheel files to release"
              TOTAL_FILES=$((TOTAL_FILES+NUM_FILES))
            fi
          else
            echo "Warning: Python directory is empty or contains no .whl files"
          fi

          # Move CMake artifacts
          if [ -d "cmake" ] && [ "$(find cmake -type f \( -name "*.zip" -o -name "*.tar.gz" \) | wc -l)" -gt 0 ]; then
            find cmake -type f \( -name "*.zip" -o -name "*.tar.gz" \) -exec cp {} release_files/ \;
            NUM_FILES=$(find release_files -name "*.zip" -o -name "*.tar.gz" | wc -l)
            if [ "$NUM_FILES" -gt 0 ]; then
              echo "Added CMake artifacts to release"
              TOTAL_FILES=$((TOTAL_FILES+NUM_FILES))
            else
              echo "No CMake artifacts found to add to release"
            fi
          else
            echo "Warning: No CMake artifacts found"
          fi

          # Move installer packages
          for installer_type in debian-package rpm-package macos-package windows-installer; do
            if [ -d "$installer_type" ] && [ "$(ls -A $installer_type)" ]; then
              find $installer_type -type f \( -name "*.deb" -o -name "*.rpm" -o -name "*.pkg" -o -name "*.msi" \) -exec cp {} release_files/ \;
              INSTALLER_COUNT=$(find release_files -type f \( -name "*.deb" -o -name "*.rpm" -o -name "*.pkg" -o -name "*.msi" \) | wc -l)
              if [ "$INSTALLER_COUNT" -gt 0 ]; then
                echo "Added installer packages to release from $installer_type"
                TOTAL_FILES=$((TOTAL_FILES+1))
              fi
            else
              echo "Warning: $installer_type directory is empty or does not exist"
            fi
          done

          # List all collected release files
          echo "Collected $TOTAL_FILES release files:"
          ls -la release_files/

          # Create a dummy file if no artifacts were found (to prevent release creation failure)
          if [ "$TOTAL_FILES" -eq 0 ]; then
            echo "WARNING: No artifacts were found for release. Creating a placeholder file."
            echo "This is a placeholder file. No artifacts were found for this release." > release_files/README.txt
          fi

      - name: Create Release
        id: create_release
        continue-on-error: true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.check-workflows-and-tag.outputs.tag_name }}
          files: artifacts/release_files/*
          generate_release_notes: true
          draft: false
          body: |
            This release includes binaries and libraries for multiple platforms.

            ## Installation
            
            ### System Packages
            
            **Linux (Debian/Ubuntu):**
            ```bash
            sudo dpkg -i colibri-server_*.deb
            sudo apt-get install -f
            ```
            
            **Linux (RPM):**
            ```bash
            sudo rpm -ivh colibri-server-*.rpm
            ```
            
            **macOS (PKG):**
            ```bash
            sudo installer -pkg colibri-server-*.pkg -target /
            ```
            
            **macOS (Homebrew):**
            ```bash
            brew tap corpus-core/colibri
            brew install colibri-server
            brew services start colibri-server
            ```
            
            **Windows (MSI):**
            ```powershell
            msiexec /i colibri-server-*.msi
            ```
            
            ### Development Libraries
            
            **Python:**
            ```bash
            pip install colibri-stateless
            ```
            
            **Swift/iOS:** Download the Swift package artifact
            
            **JavaScript/WASM:** Download the c4-wasm artifact
            
            **Android/Kotlin:** Download the AAR or JAR artifact
            
            ## Included Artifacts
            
            - System installers (DEB, RPM, PKG, MSI)
            - CMake builds (Linux, macOS, Windows)
            - Swift package (iOS/macOS)
            - JavaScript/WASM package
            - Android AAR & JVM JAR
            - Python wheels
            
            If some artifacts are missing, they may not have been successfully built in the pipeline.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Summary
        if: always()
        run: |
          echo "## Release Creation Result" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.create_release.outcome }}" == "success" ]; then
            echo "‚úÖ Successfully created release for tag ${{ needs.check-workflows-and-tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Failed to create release for tag ${{ needs.check-workflows-and-tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### Artifact Summary" >> $GITHUB_STEP_SUMMARY

          if [ -d "artifacts/cmake" ] && [ "$(find artifacts/cmake -type f | wc -l)" -gt 0 ]; then
            echo "- ‚úÖ CMake artifacts: $(find artifacts/cmake -type f | wc -l) files" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå No CMake artifacts found" >> $GITHUB_STEP_SUMMARY
          fi

          # Check all artifacts using the same definition as download step
          ARTIFACT_CHECKS=(
            "Swift package|swift_package|*"
            "WASM package|wasm|*.zip"
            "AAR package|aar|*.aar"
            "JAR package|jar|*.jar"
            "Python wheels|python|*.whl"
            "Debian packages|debian-package|*.deb"
            "RPM packages|rpm-package|*.rpm"
            "macOS packages|macos-package|*.pkg"
            "Windows installers|windows-installer|*.msi"
          )

          for artifact_check in "${ARTIFACT_CHECKS[@]}"; do
            IFS='|' read -r display_name target_path verify_pattern <<< "$artifact_check"
            
            if [ -d "artifacts/$target_path" ]; then
              if [ "$verify_pattern" != "*" ]; then
                FILE_COUNT=$(find "artifacts/$target_path" -name "$verify_pattern" 2>/dev/null | wc -l)
              else
                FILE_COUNT=$(find "artifacts/$target_path" -type f 2>/dev/null | wc -l)
              fi
              
              if [ "$FILE_COUNT" -gt 0 ]; then
                echo "- ‚úÖ $display_name: $FILE_COUNT files" >> $GITHUB_STEP_SUMMARY
              else
                echo "- ‚ùå No $display_name found" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- ‚ùå No $display_name found" >> $GITHUB_STEP_SUMMARY
            fi
          done
